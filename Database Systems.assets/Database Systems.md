# 数据库（Database Systems)

$$
\large\scr A\cal{ilan} \scr X \cal{ier}
$$

## 1.数据库基本概念

### 1.1.数据抽象

> 通过抽象来对用户屏蔽复杂性，以简化用户与系统的交互。

+ 物理层（或内部层）：

  ​	**最低层次**的抽象，描述数据实际上是**怎样存储的**和复杂的底层数据结构（存储路径、存储方式、索引方式）。

+ 逻辑层（或概念层）：

  ​	比物理层层次稍高的抽象，描述数据库中**存储什么数据**及这些**数据间关系**。

+ 视图层（或外部层）：

  ​	最高层次的抽象，只描述整个数据库的**某个部分**。用于并不需要关心所有的信息，而只需要访问数据库的一部分的用户。同一数据库有**多个视图**。

+ 实例：

  ​	特定时刻存储在数据库中的信息的集合称作数据库的一个**实例**。

+ 模式：

  ​	数据库的总体设计称作数据库**模式**（schema），是对数据库中数据所进行的一种**结构性的描述**。

  > 数据库**模式**对应于程序设计语言中的**变量声明**（以及与之关联的类型的定义）。
  >
  > 每个变量在特定的时刻会有特定的值，程序中变量在**某一时刻的值**对应于数据库模式的一个**实例**。

+ 在不同抽象层次描述数据库，就可定义出**物理模式，逻辑模式和视图模式**（也叫子模式）

+ 两层映像：

  + E-C Mapping（External Schema-Conceptual Schema Mapping）：

    ​	将**外模式**（视图模式）映射为**概念模式**（逻辑模式），从而支持实现数据概念视图向外部视图的转换，便于用户观察和使用。

    > 逻辑数据独立性：
    >
    > ​	当概念模式变化时，可以不改变外部模式（只需改变 E-C Mapping），从而无需改变应用程序。

  + C-I Mapping（Conceptual Schema-Internal Schema Mapping）：

    ​	将**概念模式**映射为**内部模式**（物理模式），从而支持实现数据概念视图向内部视图的转换，便于计算机进行存储和处理。

    > 物理数据独立性：
    >
    > ​	当内部模式（物理模式）变化时，可以不改变概念模式（只需改变 C-I Mapping），从而不改变外部模式。

### 1.2.数据模型

> 数据库结构的基础是数据模型。

+ PPT 中的分类：

  + 关系模型：表的形式组织数据。
  + 层次模型：树的形式组织数据。
  + 网状模型：图的形式组织数据。

+ 课本的分类：

  + 关系模型：

    ​	用**表**的集合来表示**数据和数据间的联系**。

  + 实体-联系（E-R：entity-relationship）模型：

    + 基于对现实世界的认识。
    + 现实世界由一组称作**实体的基本对象**以及这些**对象间的联系**构成。
    + **实体**是现实世界中可**区别于其他对象**的一件「事情」或一个「物体」

  + 基于对象的数据模型（应该不怎么学）

### 1.3.数据库系统和语言

+ 数据库系统：
  + 数据库（DB：Database） 
  + **数据库管理系统**（DBMS：Database Management System）
  + 数据库应用（DBAP: DataBaseApplication） 
  + 数据库管理员（DBA: DataBaseAdministrator）

+ 数据库语言（DBMS 提供的）：

  + 数据定义语言（DDL：Data Definition Language）：定义表名，表标题，列名及其结构形式。

    > 新数据插入时（更新数据库时）要检查**完整性约束**，防止不符合规范的数据进入数据库：
    >
    > + 域约束：
    >
    >   ​	每个属性都必须对应于一个**所有可能的取值构成的域**（例如，整数型、字符型、日期/时间型）。域约束是完整性约束的最基本形式。
    >
    > + 参照（引用）完整性：
    >
    >   ​	一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现。
    >
    > + 断言：
    >
    >   ​	一个断言就是数据库需要**始终满足的某一条件**（域约束和参照完整性约束是断言的特殊形式），例如：「每一学期每一个系必须至少开设 $5$ 门课程」只能表达成一个断言。如果断言有效，则以后只有不破坏断言的数据库更新才被允许。

  + 数据操纵语言（DML：Data Manipulation Language）：对数据库进行**增、删、改、查**等操作。
  + 数据控制语言（DCL：Data Control Language）：对不同操作和用户的约束。

## 2.关系模型

### 2.1.定义

+ 表的列，也叫字段/属性/数据项，包括列名和列值。

+ 表的行，也叫元组（$n$ 元组就是一个有 $n$ 个值的元组）/记录。

+ 域：

  ​	对于关系的每个**属性**，都存在一个允许取值的集合（即**域**），这组值具有相同的数据类型。

  > 集合中元素的个数称为域的**基数**。

+ 域的笛卡尔积：

  ​	一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积为：$D_1×D_2×\cdots×D_n = \{ (d_1 , d_2 , … , d_n) | d_i∈D_i , i=1,\cdots,n\}$，笛卡尔积每个元素 $(d_1 , d_2 , … , d_n)$ 称作一个 $n$ - 元组。

+ 关系：

  ​	一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积的**子集**。

+ **关系模式或表标题**：

  ​	用 $R\left(A_{1}: D_{1}, A_{2}: {D}_{2}, \ldots, {A}_{{n}}: {D}_{{n}}\right)$ 表示，可简记为 ${R}\left({A}_{1}, {A}_{2}, \ldots, {A}_{{n}}\right)$ 来描述关系：

  + $R$ 是关系的名字。
  + ${A}_{{i}}$ 是**属性**。
  + ${D}_{{i}}$ 是属性所对应的**域**（属性的类型、长度）。
  + $n$ 是关系的**度或目**，即有多少列。
  + 关系模式中 $A_i (i = 1,\cdots,n)$ 必须是不同的, 而 $D_i(i = 1,\cdots,n)$ 是可以相同的。

### 2.2.关系的特性

+ 列是同质：

  ​	每一列中的列值来自同一域，是同一类型的数据。

+ 列位置互换性：

  ​	区分哪一列是靠列名，与列的顺序无关。

+ 行位置互换性：

  ​	区分哪一行是靠某一或某几列的值（关键字/键字/码字）。

+ 任意两个元组不能完全相同。

+ 属性不可再分特性（关系第一范式）

### 2.3.码（键）

+ 超码（superkey）：

  ​	**超码**是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中**唯一地标识一个元组**。

  > 两个不同元组的超码属性的取指不会完全相同。

+ 候选码：

  ​	如果一个超码的任意真子集都不能成为超码，这样的最小超码称为**候选码**。

+ 主码：

  ​	当有多个候选码时，可以选定一个作为**主码**。

+ 主属性与非主属性：

  ​	包含在**任何一个候选码**中的属性被称作**主属性**，其他属性被称作**非主属性**。

  > 可能出现关系的所有属性组是这个关系的候选码，称为**全码**。

+ 外码：

  ​	关系 $R$ 中的一个属性组，它不是 $R$ 的候选码，但它与另一个关系候选码（主码）相对应，则称这个属性组为 $R$ 的**外码**。

### 2.4.关系模型中的完整性

+ **实体完整性**：

  ​	关系的**主码**中的属性值不能为**空值**。

+ **参照完整性**：

  ​	如果关系 $R_1$ 的**外码** $a$ 与关系 $R_2$ 的**主码** $a$ 相对应，则 $R_1$ 中的**每一个元组**的 $a$ 值或者等于 $R_2$ 中**某个元组**的 $a$ 值 ，或者为**空值**。

+ 用户自定义完整性：

  ​	用户针对具体的应用环境定义的完整性约束条件。

## 3.数据库设计

### 3.1.实体-联系（E-R）模型

+ E-R 模型的基本观点：

  ​	世界是由一组称作**实体的基本对象和这些对象之间的联系**构成的。

+ 实体：

  ​	**实体**是现实世界中可区别于所有其他对象的一个「事物」或「对象」。每个实体有一组性质（属性），其中一些性质的值可以唯一地标识一个实体。

+ 实体集：

  ​	**实体集**是相同类型即具有**相同性质（或属性）**的一个实体集合。

  > 注意：以上是课本的定义，PPT 中的「实体」= 课本的「实体集」，PPT 的「实例」= 课本的「实体」。
  >
  > 以下用书本的定义描述。

+ 联系集：

  + **联系**是指**多个实体间**的相互关联。

  + **联系集**是相同类型联系的集合。正规地说，联系集是 $n \geqslant 2$ 个（可能相同的）实体集上的数学关系。如果 $E_{1}, E_{2}, \cdots, E_{n}$ 为实体集，那么联系集 $R$ 是
    $$
    \left\{\left(e_{1}, e_{2}, \cdots, e_{n}\right) \mid e_{1} \in E_{1}, e_{2} \in E_{2}, \cdots, e_{n} \in E_{n}\right\}
    $$
    的一个**子集**（相当于实体集笛卡尔积的一个子集），而 $\left(e_{1}, e_{2}, \cdots, e_{n}\right)$ 是一个**联系**，$e_i$ 是 $E_i$ 的属性集合的子集。

    > 实体集之间的关联称为**参与**。实体集 $E_{1}, E_{2}, \cdots, E_{n}$ 参与联系集 $R$。

  + 参与联系集的**实体集的数目**称为联系集的**度**。

  + 实体在联系中扮演的功能称为实体的**角色**。

+ 属性：

  + 每个属性都有一个可取值的集合，称为该属性的**域或者值集**。
  + 属性的分类：
    + 简单（单一）属性：它们不能划分为更小的部分。
    + 复合属性：将属性再划分为更小的部分（即其他属性）。
    + 单值属性：对一个特定实体，一个属性都只有**单独的一个值**。
    + 多值属性：对某个特定实体而言，一个属性可能对应于**一组值**（即一个属性可以取多个值）。

+ 联系集的类型：

  + 一对一，$A$ 中的一个实体**至多**与 $B$ 中的一个实体相关联，并且 $B$ 中的一个实体也至多与 $A$ 中的一个实体相关联。
  + 一对多，$A$ 中的一个实体可以与 $B$ 中的**任意数目（零个或多个）**实体相关联，而 $B$ 中的一个实体至多与 $A$ 中的一个实体相关联。
  + 多对一，$A$ 中的一个实体至多与 $B$ 中的一个实体相关联，而 $B$ 中的一个实体可以与 $A$ 中任意数目（零个或多个）实体相关联。
  + 多对多，$A$ 中的一个实体可以与 $B$ 中任意数目（零个或多个）实体相关联，而且 $B$ 中的一个实体也可以与 $A$ 中任意数目（零个或多个）实体相关联。

+ 映射基数（联系的基数）：

  ​	实体之间的联系的数量，即**一个实体**通过一个**联系**能与**另一实体集相关联的实体的数目**。

+ 实体集和二元联系集之间的一条边，可以有一个关联的**最大和最小的映射基数**。

  > 例如：
  >
  > ![image-20211004133238514](.\Database Systems.assets\image-20211004133238514.png)
  >
  > 一个 instructor 可以对应 **$0$ 个或多个** student，但一个 student **有且仅有一个** instructor，注意 advisor 联系是从 instructor 到 student的**一对多**联系。

+ 参与约束：

  + 完全参与联系：如果实体集 $E$ 中的**每个实体**都参与到联系集 $R$ 的**至少一个**联系中，此时最小基数为 $1$。
  + 部分参与联系：如果 $E$ 中只有**部分实体**参与到 $R$ 的联系中，此时最小基数为 $0$。

+ 弱实体集和强实体集：
  + 没有**足够的属性以形成主码**的实体集称作**弱实体集**（从属实体集）。
  + 有**主码**的实体集称作**强实体集**（独立实体集）。

### 3.2.数据库设计

+ 需求分析：

  ​	形成数据库设计的「源」清单和「属性」清单。

+ 概念数据库设计：

  + 用统一的表达方法，如 E-R 模型给出描述：

    + 各种实体的发现、划分和定义

    + 各种实体属性的发现、分析和定义
    + 各种实体联系的发现、分析和定义
    + 外部视图（模式）和概念视图（模式）的定义
  
  + 消除冲突：
  
    + 属性冲突：
      + 属性域的冲突（属性的类型、取值范围不同）
      + 属性取值单位冲突
    + 结构冲突：
      + 同一对象在不同应用中的抽象不同（职工在某应用中是实体，在另一应用中则抽象为属性）
      + 同一实体在不同 E-R 图中属性组成不同
      + 实体之间的联系在不同 E-R 图中呈现不同的类型
    + 命名冲突（同名异义，异名同义）
  
+ 逻辑数据库设计：

  + E-R 图转换为关系模式：

    + 一对一联系：

      + 若联系双方**均部分参与**，则将**联系**定义为一个**新的关系**，属性为参与双方的关键字（主码）属性。
      + 若联系**一方全部参与**，则将**另一方关键字**作为**全部参与方**的**属性**（即多一个属性），不需要联系集（感觉是 PPT 说反了）。

    + 一对多联系：

      ​	将**单方**（如教师和学生关系中的教师）参与实体的关键字，作为**多方**（学生）参与实体对应关系的属性。

    + 多对多联系：

      ​	将联系定义为**新的关系**，属性为参与**双方实体的关键字**。

  + 冗余（没懂）：

    + 受控冗余
    + 非受控冗余：存在传递函数依赖。

### 3.3.函数依赖

+ 函数依赖定义：

  + 设 $ {R}$ 是属性集合 $U=\left\{A_{1}, A_{2}, \ldots, A_{n}\right\}$ 上的一个关系模式，$X, Y$ 是**属性集** $U$ 上的两个**子集**。

  + 若对 $R$ 的任意关系 $r$，$  {r}$ 中**不可能有两个元组**满足在 $X$ 中的属性值相等而在 $Y$ 中的属性值不等，则称「$X$ 函数决定 $Y$」或「$Y$ 函数依赖于  $X$」，记作 $X \rightarrow Y$，称 $X$ 为决定因素，$Y$ 为依赖因素。

    > 关系模式是在属性集合上的结构化描述，关系是表状结构的。
    >
    > 函数依赖，顾名思义，$X$ 映射到 $Y$ ，同一个 $x$ 不会映射到两个 $y$。

+ 函数依赖的特性：
  
  + 如果 $Y\sub X$，则有 $X\to Y$。
  
  + 对 $ {X} \rightarrow  {Y}$，但 $ {Y} \not \subset  {X}$，则称 $X\rightarrow  {Y}$ 为**非平凡的函数依赖**。
  + 若 $X \rightarrow Y, Y \rightarrow X$，则记作 $X \leftrightarrow Y$。
  + 若 $Y$ 不函数依赖于 $X$. 则记作 $X \not\rightarrow Y$。
  + $ {X} \rightarrow  {Y}$，若是基于模式 $R$ 的，则对任意的关系 $r$ 成立；若仅基于具体关系 $ {r}$ 的，则可能只对该关系 $r$ 成立。
  + 如一关系 $r$ 的某属性集 $X$，$r$ 中**没有 $X$ 上相等的两个元组**，则 $ {X} \rightarrow  {Y}$ 恒成立。

+ 完全函数依赖和部分函数依赖：

  ​	在 $R$ 中，若 $X \rightarrow Y$ 并且对于 $X$ 的任何真子集 $X'$ 都有 $X'\not\rightarrow Y$，则称 $Y$ **完全（full）函数依赖**于 $X$，记为$X\stackrel{{f}}{\rightarrow} {Y}$，否则称 $Y$ **部分（partial）函数依赖**于 ${X}$，记为 ${X} \stackrel{{p}}\to {Y}$。

  >  $ {R}$ 是属性集合 $U$ 上的一个关系模式，若 $X\sub U$ 且 $X\stackrel{{f}}{\rightarrow} {U}$，则称 $X$ 为 $R$ 的**候选键**（候选码）。

+ 传递函数依赖：

  ​	在 $R$ 中，若 $X\to Y,Y \to Z$，其中 $Y\not\sub X,Z\not\sub Y,Z\not\sub X,Y\not\to X$（说明都是**非平凡依赖**），则称 $Z$ **传递函数依赖**于 $X$。 

+ 逻辑蕴涵：

  ​	设 $F$ 是关系模式 $R$ 的一个**函数依赖集合**， $X,Y$ 是 $R$ 的属性子集，若从 $F$ 的函数依赖能够推导出 $X \rightarrow Y$，则称 $F$ 逻辑蕴涵 $X \rightarrow Y$，记作 ${F} \models {X} \rightarrow{Y}$ 。

+ 闭包：

  ​	令 $F$ 为一个函数依赖集，$F$ 的**闭包**是被 $F$ **逻辑蕴涵的所有函数依赖**的集合, 记作 $F^{+}$。若 $F^+=F$，则 $F$ 是一个**全函数依赖族（函数依赖完备集）**。

  > 在下面的规则中去寻找逻辑蕴涵的函数依赖，通过反复应用这些规则，可以找到给定 $F$ 的全部 $F^{+}$。
  >
  > 用希腊字母 $(\alpha, \beta, \gamma, \cdots)$ 表示属性集，用 $\alpha \beta$ 表示 $\alpha \cup \beta_{\circ}$
  > 这组规则称为 Armstrong 公理：
  >
  > - 自反律：若 $\alpha$ 为一属性集且 $\beta \subseteq \alpha$，则 $\alpha \rightarrow \beta$ 成立。
  > - 增补律：若 $\alpha \rightarrow \beta$ 成立且 $\gamma$ 为一属性集，则 $\gamma \alpha \rightarrow \gamma \beta$ 成立。
  > - 传递律：$\alpha \rightarrow \beta$ 和 $\beta \rightarrow \gamma$ 成立，则 $\alpha \rightarrow \gamma$ 成立。
  >
  > 公理可导出的比较好用的引理：
  >
  > + **合并律**：若 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立, 则 $\alpha \rightarrow \beta \gamma$ 成立。 
  > + **分解律**：若 $\alpha \rightarrow \beta \gamma$ 成立, 则 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立。 
  > + 伪传递律：若 $\alpha \rightarrow \beta$ 和 $\gamma \beta \rightarrow \delta$ 成立, 则 $\alpha \gamma \rightarrow \delta$ 成立（由 $\alpha \rightarrow \beta$ 得到 $\gamma\alpha \rightarrow \gamma\beta$，再由传递律得到结论）。

+ 属性集闭包：
  
  ​	对 $  {R}(  {U},   {F}),   {X} \subseteq   {U},   {U}=\left\{  {A}_{1},  {~A}_{2}, \ldots,   {A}_{ {n}}\right\}$，令：$  {X}^{+}_{F}=\left\{  {A}_{  {i}} \mid\right. 用Armstrong ~公理可从 F 导出 \left.  {X} \rightarrow   {A}_{  {i}}\right\}$ 称 $  {X}^{+}{ }_{ {F}}$ 为 X 于 $F$ 的**属性集闭包**。
  显然 $X \subseteq X^{+}{ }_{F}$。

  > 引理：$  {X} \rightarrow   {Y}$, 当且仅当 $  {Y} \subseteq   {X}_{  {F}}^{+}$ 。
  
+ 覆盖：

  ​	对 $R(U)$ 上的两个函数依赖集合 $F,G$，如果 $F^+= G^+$，则称 $F$ 和 $G$ 是**等价**的，也称 $F$ **覆盖** $G$ 或者 $G$ 覆盖 $F$。

+ 最小覆盖：

  ​	若 $F$ 满足以下条件，则称 $F$ 为**最小覆盖或最小依赖集**：

  + $F$ 中**每个函数依赖的右部是单个属性**。
  + 对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。
  + 对任何 $\{X\to A\} \in F$，$Z\sub X$，$(F- \{ X\to A \})\cup\{Z\to A\}$ 不等价于 $F$。

### 3.4.关系模式范式

+ 第一范式：

  ​	如果关系模式 $R$ 所有属性的域都是原子，则称 $R$ 属于第一范式（$1NF$）, 记作 $R \in 1NF$。

  > $1NF $ 要求关系中不能有复合属性、多值属性及其组合。
  >
  > 多值属性解决方案：
  >
  > ![image-20211005105615752](.\Database Systems.assets\image-20211005105615752.png)
  >
  > + 拆成两个表，原表去掉多值列，然后把多值属性和主码作为一个新的表。
  > + 拆成多行
  > + 拆成多列

+ 第二范式：

  ​	若 $R(U)\in 1NF$ 且 $U$ 中的每一**非主属性完全函数依赖**于**候选键**，则称 $R(U)$ 属于第二范式，记为：$R(U)\in 2NF$。

  > 第二范式消除非主属性对候选键的**部分依赖**。
  >
  > 将候选键拆成多个表，每个表的**非主属性**完全函数依赖于候选键。
  >
  > 第二范式只有历史意义，已经不在实际中使用了。

+ 第三范式：

  ​	在 $R$ 中若不存在**候选键** $X$，**属性集** $Y$，和**非主属性** $Z$，使得 $X\to Y,Y \to Z$ 成立，其中 $Y\not\sub X,Z\not\sub Y,Z\not\sub X,Y\not\to X$，则称 $R$ 属于第三范式，记为：$R\in 3NF$。

  > 第 $3$ 范式消除了**非主属性对侯选键的传递依赖**。
  >
  > 如满足第 $3$ 范式，则一定能满足第 $2$ 范式。

+ Boyce-Codd 范式：

  ​	若 $R(U,F)\in 1NF$, 若对于任何 $X\to Y\in F$（或 $X\to A\in F$），当 $Y\not\sub X$（或 $A\in X$）时，$X$ 必含有**候选键**，则称 $R(U)$ 属于 Boyce-Codd 范式，记为：$R(U)\in BCNF$。

  > 如满足 Boyce-Codd 范式，则一定能满足第 $3$ 范式。

+ 多值依赖：

  ​	对 $R(U)$，设 $X,Y\sub U$，若对于 $R(U)$ 的任一关系 $r$，若元组 $t\in r, s\in r,{t}[ {X}]= {s}[ {X}]$，则必有 $ {u} \in  {r},  {v} \in  {r}$ 使得：
  + $u[X]=v[X]=t[X]=s[X]$
  
  + $ {u}[ {Y}]= {t}[ {Y}]$ 且 $u[ {U}- {X}- {Y}]= {s}[ {U}- {X}- {Y}]$
  
  + $ {v}[ {Y}]= {s}[ {Y}]$ 且 $v[U- {X}- {Y}]= {t}[ {U}- {X}- {Y}]$
  
    | $X$  |  $Y$  | $U-X-Y$ |
    | :--: | :---: | :-----: |
    | $x$  | $y_1$ |  $z_1$  |
    | $x$  | $y_2$ |  $z_2$  |
    | $x$  | $y_2$ |  $z_1$  |
    | $x$  | $y_1$ |  $z_2$  |
  
  均成立，则称 $Y$ **多值依赖于** $X$，或说 $X$ **多值决定** $ {Y}$，记作 $ {X} \rightarrow \rightarrow  {Y}$，同时 $X \to\to U-X-Y$。
  
  > 若 $U=X\cup Y$ ，则一定有 $X\to\to Y$。
  >
  > 直观地，若 $ {X} \rightarrow \rightarrow  {Y}$，对于 $X$ 给定值，$Y$ 有一组值与之对应（$0$ 或 $n$ 个）且这组 $Y$ 值不以任何方式与 $U-X-Y$ 中属性值相联系。

+ 第四范式（基于多值依赖的 BCNF 范式）：

  ​	函数依赖和多值依赖集为 $F$ 的关系模式 $R(U)$ 属于第四范式 $(4  {NF})$ 的条件是，对 $F^{+}$中所有形如 $\alpha \rightarrow \beta$ 的多值依赖（其中 $\alpha \subseteq 	U$ 且 $\beta \subseteq U$），至少有以下之一成立：

  - $\alpha \rightarrow \beta$ 是一个平凡的多值依赖。
  - $\alpha$ 是 $R$ 的一个超码。

### 3.5.模式分解

+ 模式分解定义：

  ​	关系模式 $R(U)$ 的分解是指用 $R$ 的一组子集 $\rho=\left\{ {R}_{1}, \ldots,  {R}_{ {k}}\right\}$ 来代替它。其中 $ {U}= {U}_{1} \cup  {U}_{2} \cup \ldots \cup  {U}_{ {k}},{U}_{ {i}} \notin  {U}_{ {j}}( {i} \neq  {j})$ 。对于关系模式 $R$ 的任一关系 $r$，它向 $\rho$ 的投影连接记为 $ {m}_{\rho}( {r})$ :
  $$
  {m}_{\rho}( {r})=\pi_{ {R}_{1}}( {r}) \bowtie \ldots \bowtie \pi_{ {R}_{ {k}}}( {r})=\bowtie_{( {i}=1, \ldots,  {k})} \pi_{ {R}_{ {i}}}( {r})
  $$
  这里 : $\pi_{ {R}_{ {i}}}( {r})=\left\{ {t}\left[ {R}_{ {i}}\right] \mid  {t} \in  {r},  {i}=1, \ldots,  {k}\right\}$。
  
  > 若对关系模式 $R$ 的任一关系 $r$ 都有 $r = m_\rho(r)$ 成立，则称 $\rho$ 是 $R$ 相对于 $F$ 的一个**无损连接分解**。
  
+ 无损连接分解检验算法：

  + 构造一 $k$ 行 $n$ 列的表（$k$ 是分解的集合数，$n$ 是 $R(U)$ 属性数），可称为 $ {R}_\rho$ 表。
  + 其中第 $j$ 列对应于 $ {A}_{ {j}}$，第 $i$ 行对应于 $ {R}_{ {i}}$。
  + 若 $ {A}_{ {j}} \in  {R}_{ {i}}$，则 $ {R}_{\rho}$ 表中第 $i$ 行第 $j$ 列位置填写符号 $ {a}_{ {j}}$，否则填写 $ {b}_{ {ij}}$ 。
  + 根据 $\forall( {X} \rightarrow  {Y}) \in  {F}$，对 $ {R}_{\rho}$ 表进行修改：给定 $ {X} \rightarrow  {Y}$，寻找 **$X$ 属性取值相同**的行，用其值重置 $Y$ 属性值（$a$ 或 $b$，其实相当于归为一个并查集里）。
  + 修改后，如果有一行变成 $ {a}_{1},  {a}_{2}, \ldots,  {a}_{ {n}}$，则 $\rho$ 是无损连接分解，否则为有损连接分解。
  
  > 对于分解成两个子集的情况，可以快速判断的方法：
  >
  > + 设 $F$ 是关系模式 $R$ 上的一个函数依赖集合，$\rho=\left\{ {R}_{1},  {R}_{2}\right\}$ 是 $R$ 的一个分解。
  >
  > + 则当且仅当 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{1}- {R}_{2}$ 或者 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{2}- {R}_{1}$ 属于 $F^+$ 时，$\rho$ 是关于$F$ 无损连接的。
  >
  > + 因为 $R_1=(R_1\cap R_2) \cup(R_1-R_2),R_2=(R_1\cap R_2) \cup(R_2-R_1)$，所以有
  >
  >   |       | $R_1\cap R_2$ | $R_1- R_2$ | $R_2- R_1$ |
  >   | :---: | :-----------: | :--------: | :--------: |
  >   | $R_1$ |     $a_1$     |   $a_2$    |  $b_{13}$  |
  >   | $R_2$ |     $a_1$     |  $b_{22}$  |   $a_3$    |
  >
  > + 此时只要 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{1}- {R}_{2}$ 或者 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{2}- {R}_{1}$ 属于 $F^+$ 的一个成立，就能实现有一行变成 $ {a}_{1},  {a}_{2},{a}_3$。
  
+ 保持依赖分解的分解：

  + 对于关系模式 $R( {U},  {F})$，${U}$ 是属性全集，$F$ 是函数依赖集合，$\rho=\left\{ {R}_{1}, \ldots,  {R}_{ {k}}\right\}$ 是 $R$ 的一个分解。
  + 如在 $\pi_{ {R_i}}( {F})$ 中的所有依赖之并集 $( {i}=1, \ldots,  {k})$，**逻辑蕴涵 $F$ 的每个依赖**，则称分解 $\rho$ 保持依赖集 $F$。
  + 其中 $\pi_{ {R_i}}( {F})$ 是 $F$ 在 $ {R}_{ {i}}$ 上的投影，即 $F$ 中的任一投影 $ {X} \rightarrow  {Y}$，如果 $X,Y\in R_i$，则 $ {X} \rightarrow  {Y} \in \pi_{ {R_i}}( {F})$。

+ 保持依赖分解检测算法：

  > 对 $F$ 中的每一个 $\alpha \rightarrow \beta$，
  > $result =\alpha$
  > $while$
  > 		$for ~each$ 分解后包含有 $\alpha$ 的 $R_{i}:$
  > 				$t=\left( result \cap R_{i}\right)^{+} \cap R_{i}$
  > 				$result = result \cup t$
  > $until ~(~result$ 没有变化 $)$ 
  >
  > 如果 $result$ 含 $F$ 中的所有属性，则函数依赖 $\alpha\to \beta$ 保持。

+ BCNF 分解 + 无损连接分解：

  > BCNF 范式要求每个函数依赖的左侧都要是关系模式的**超键**。

  + 仅 BCNF 分解：

    ​	将左侧不含候选键的函数依赖**单独组成一个关系**，将包含候选键的组成一关系。

  + 无损连接分解成 BCNF：

    > 计算 $F^{+}$
    > $while ~(~result \not\in BCNF~)~ do:$
    > 		$if (result$ 中存在模式 $R_{i}$ 不属于 $BCNF )$
    > 				对于 $R_{i}$ 上所有非平凡函数依赖 $\alpha \rightarrow \beta$ （ 满足 $\alpha \rightarrow R_{i}$ 不属于 $F^{+}$，即 $\alpha$ 不是 $R_i$ 的超键）
    > $\quad$ 					 $result =\left(\right. result \left.-R_{i}\right) \cup\left(R_{i}-\beta\right) \cup(\alpha, \beta) $ （即用两个模式 $\left(R_{i}-\beta\right) \cup(\alpha, \beta)$ 取代原来的 $R_i$，由之前的快速判断的方法可知分解无损） 

+ $3NF$ 分解 + 保持依赖分解（+ 无损连接分解）：

  + 仅 $3NF$ 分解：

    ​	将每一个函数依赖单独组成一个关系。

  + 持依赖分解成 $3NF$：

    + 关系模式 $R(U, F)$，$F$ 是函数依赖集**最小覆盖**，$\rho$ 为所求分解。

    + 若有 $ {X} \rightarrow  {A}_{1},  {X} \rightarrow  {A}_{2}, \ldots,  {X} \rightarrow  {A}_{ {m}}\in{F}$，则以 $ {XA}_{1}  {~A}_{2} \ldots  {A}_{ {m}}$ 组成一模式 $R_i$，$\rho=\rho\cup R_i$

      > 因为 $F$ 是最小覆盖，要求对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。
      >
      > 所以一定不会存在 $A_i\to A_j\in F(i\not=j)$ 的情况，否则 $F-\{X\to A_j\}$ 仍等价于 $F$。

    + 上一步处理完后，把 $R$ 中不出现在 $F$ 中的属性去掉并单独组成一模式。

      > 如果这一模式存在，将这个模式加上候选键属性，则能使该分解达到无损。
      >
      > 如果并不存在，则判断所得 $\rho$ 集合中的是否存在一个 $R_i$ 包含了属性集。如果不存在，则给 $\rho$ 并上候选键属性集达到无损分解。

## 4.数据存储和查询

### 4.1.存储和文件结构

+ 磁盘结构：

  <img src=".\Database Systems.assets\image-20211012161544352.png" alt="image-20211012161544352" style="zoom: 67%;" />

  + 盘片的表面从逻辑上划分为磁道，磁道又划分为扇区，扇区是从磁盘读出和写入信息的最小单位。

+ 磁盘数据读写时间：

  + 

+ RAID 技术：



### 4.2.索引

+ 
+ 索引应用的评价：
  + 访问时间：在查询中使用该技术找到一个特定数据项或数据项集所需的时间
  + 插入时间：插入一个新数据项所需的时间。该值包括找到插入这个新数据项的 正确位置所需的时间，以及更新索引结构所需的时间。 
  + 删除时间：删除一个数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。 
  + 空间开销：索引结构所占用的额外存储空间。倘若存储索引结构的额外空间大小适度，通常牺牲一定的空间代价来换取性能的提高是值得的。









