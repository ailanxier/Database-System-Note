# 数据库（Database Systems)
$$
\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}\large\scr A\cal{ilan} \scr X \cal{ier}
$$

## 1.数据库基本概念

### 1.1.数据抽象

> 通过抽象来对用户屏蔽复杂性，以简化用户与系统的交互。

+ 物理层（或内部层）：

  ​	**最低层次**的抽象，描述数据实际上是**怎样存储的**和复杂的底层数据结构（存储路径、存储方式、索引方式）。

+ 逻辑层（或概念层）：

  ​	比物理层层次稍高的抽象，描述数据库中**存储什么数据**及这些**数据间关系**。

+ 视图层（或外部层）：

  ​	最高层次的抽象，只描述整个数据库的**某个部分**。用于并不需要关心所有的信息，而只需要访问数据库的一部分的用户。同一数据库有**多个视图**。

+ 实例：

  ​	特定时刻存储在数据库中的信息的集合称作数据库的一个**实例**。

+ 模式：

  ​	数据库的总体设计称作数据库**模式**（schema），是对数据库中数据所进行的一种**结构性的描述**。

  > 数据库**模式**对应于程序设计语言中的**变量声明**（以及与之关联的类型的定义）。
  >
  > 每个变量在特定的时刻会有特定的值，程序中变量在**某一时刻的值**对应于数据库模式的一个**实例**。

+ 在不同抽象层次描述数据库，就可定义出**物理模式，逻辑模式和视图模式**（也叫子模式）

+ 两层映像：

  + E-C Mapping（External Schema-Conceptual Schema Mapping）：

    ​	将**外模式**（视图模式）映射为**概念模式**（逻辑模式），从而支持实现数据概念视图向外部视图的转换，便于用户观察和使用。

    > 逻辑数据独立性：
    >
    > ​	当概念模式变化时，可以不改变外部模式（只需改变 E-C Mapping），从而无需改变应用程序。

  + C-I Mapping（Conceptual Schema-Internal Schema Mapping）：

    ​	将**概念模式**映射为**内部模式**（物理模式），从而支持实现数据概念视图向内部视图的转换，便于计算机进行存储和处理。

    > 物理数据独立性：
    >
    > ​	当内部模式（物理模式）变化时，可以不改变概念模式（只需改变 C-I Mapping），从而不改变外部模式。

### 1.2.数据模型

> 数据库结构的基础是数据模型。

+ PPT 中的分类：

  + 关系模型：表的形式组织数据。
  + 层次模型：树的形式组织数据。
  + 网状模型：图的形式组织数据。

+ 课本的分类：

  + 关系模型：

    ​	用**表**的集合来表示**数据和数据间的联系**。

  + 实体-联系（E-R：entity-relationship）模型：

    + 基于对现实世界的认识。
    + 现实世界由一组称作**实体的基本对象**以及这些**对象间的联系**构成。
    + **实体**是现实世界中可**区别于其他对象**的一件「事情」或一个「物体」

  + 基于对象的数据模型（应该不怎么学）

### 1.3.数据库系统和语言

+ 数据库系统：
  + 数据库（DB：Database） 
  + **数据库管理系统**（DBMS：Database Management System）
  + 数据库应用（DBAP: DataBaseApplication） 
  + 数据库管理员（DBA: DataBaseAdministrator）

+ 数据库语言（DBMS 提供的）：

  + 数据定义语言（DDL：Data Definition Language）：定义表名，表标题，列名及其结构形式。

    > 新数据插入时（更新数据库时）要检查**完整性约束**，防止不符合规范的数据进入数据库：
    >
    > + 域约束：
    >
    >   ​	每个属性都必须对应于一个**所有可能的取值构成的域**（例如，整数型、字符型、日期/时间型）。域约束是完整性约束的最基本形式。
    >
    > + 参照（引用）完整性：
    >
    >   ​	一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现。
    >
    > + 断言：
    >
    >   ​	一个断言就是数据库需要**始终满足的某一条件**（域约束和参照完整性约束是断言的特殊形式），例如：「每一学期每一个系必须至少开设 $5$ 门课程」只能表达成一个断言。如果断言有效，则以后只有不破坏断言的数据库更新才被允许。

  + 数据操纵语言（DML：Data Manipulation Language）：对数据库进行**增、删、改、查**等操作。
  + 数据控制语言（DCL：Data Control Language）：对不同操作和用户的约束。

## 2.关系模型

### 2.1.定义

+ 表的列，也叫字段/属性/数据项，包括列名和列值。

+ 表的行，也叫元组（$n$ 元组就是一个有 $n$ 个值的元组）/记录。

+ 域：

  ​	对于关系的每个**属性**，都存在一个允许取值的集合（即**域**），这组值具有相同的数据类型。

  > 集合中元素的个数称为域的**基数**。

+ 域的笛卡尔积：

  ​	一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积为：$D_1×D_2×\cdots×D_n = \{ (d_1 , d_2 , … , d_n) | d_i∈D_i , i=1,\cdots,n\}$，笛卡尔积每个元素 $(d_1 , d_2 , … , d_n)$ 称作一个 $n$ - 元组。

+ 关系：

  ​	一组域 $D_1,D_2,\cdots,D_n$ 的笛卡尔积的**子集**。

+ **关系模式或表标题**：

  ​	用 $R\left(A_{1}: D_{1}, A_{2}: {D}_{2}, \ldots, {A}_{{n}}: {D}_{{n}}\right)$ 表示，可简记为 ${R}\left({A}_{1}, {A}_{2}, \ldots, {A}_{{n}}\right)$ 来描述关系：

  + $R$ 是关系的名字。
  + ${A}_{{i}}$ 是**属性**。
  + ${D}_{{i}}$ 是属性所对应的**域**（属性的类型、长度）。
  + $n$ 是关系的**度或目**，即有多少列。
  + 关系模式中 $A_i (i = 1,\cdots,n)$ 必须是不同的, 而 $D_i(i = 1,\cdots,n)$ 是可以相同的。

### 2.2.关系的特性

+ 列是同质：

  ​	每一列中的列值来自同一域，是同一类型的数据。

+ 列位置互换性：

  ​	区分哪一列是靠列名，与列的顺序无关。

+ 行位置互换性：

  ​	区分哪一行是靠某一或某几列的值（关键字/键字/码字）。

+ 任意两个元组不能完全相同。

+ 属性不可再分特性（关系第一范式）

### 2.3.码（键）

+ 超码（superkey）：

  ​	**超码**是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中**唯一地标识一个元组**。

  > 两个不同元组的超码属性的取指不会完全相同。

+ 候选码：

  ​	如果一个超码的任意真子集都不能成为超码，这样的最小超码称为**候选码**。

+ 主码：

  ​	当有多个候选码时，可以选定一个作为**主码**。

+ 主属性与非主属性：

  ​	包含在**任何一个候选码**中的属性被称作**主属性**，其他属性被称作**非主属性**。

  > 可能出现关系的所有属性组是这个关系的候选码，称为**全码**。

+ 外码：

  ​	关系 $R$ 中的一个属性组，它不是 $R$ 的候选码，但它与另一个关系候选码（主码）相对应，则称这个属性组为 $R$ 的**外码**。

### 2.4.关系模型中的完整性

+ **实体完整性**：

  ​	关系的**主码**中的属性值不能为**空值**。

+ **参照完整性**：

  ​	如果关系 $R_1$ 的**外码** $a$ 与关系 $R_2$ 的**主码** $a$ 相对应，则 $R_1$ 中的**每一个元组**的 $a$ 值或者等于 $R_2$ 中**某个元组**的 $a$ 值 ，或者为**空值**。

+ 用户自定义完整性：

  ​	用户针对具体的应用环境定义的完整性约束条件。

## 3.数据库设计

### 3.1.实体-联系（E-R）模型

+ E-R 模型的基本观点：

  ​	世界是由一组称作**实体的基本对象和这些对象之间的联系**构成的。

+ 实体：

  ​	**实体**是现实世界中可区别于所有其他对象的一个「事物」或「对象」。每个实体有一组性质（属性），其中一些性质的值可以唯一地标识一个实体。

+ 实体集：

  ​	**实体集**是相同类型即具有**相同性质（或属性）**的一个实体集合。

  > 注意：以上是课本的定义，PPT 中的「实体」= 课本的「实体集」，PPT 的「实例」= 课本的「实体」。
  >
  > 以下用书本的定义描述。

+ 联系集：

  + **联系**是指**多个实体间**的相互关联。

  + **联系集**是相同类型联系的集合。正规地说，联系集是 $n \geqslant 2$ 个（可能相同的）实体集上的数学关系。如果 $E_{1}, E_{2}, \cdots, E_{n}$ 为实体集，那么联系集 $R$ 是
    $$
    \left\{\left(e_{1}, e_{2}, \cdots, e_{n}\right) \mid e_{1} \in E_{1}, e_{2} \in E_{2}, \cdots, e_{n} \in E_{n}\right\}
    $$
    的一个**子集**（相当于实体集笛卡尔积的一个子集），而 $\left(e_{1}, e_{2}, \cdots, e_{n}\right)$ 是一个**联系**，$e_i$ 是 $E_i$ 的属性集合的子集。

    > 实体集之间的关联称为**参与**。实体集 $E_{1}, E_{2}, \cdots, E_{n}$ 参与联系集 $R$。

  + 参与联系集的**实体集的数目**称为联系集的**度**。

  + 实体在联系中扮演的功能称为实体的**角色**。

+ 属性：

  + 每个属性都有一个可取值的集合，称为该属性的**域或者值集**。
  + 属性的分类：
    + 简单（单一）属性：它们不能划分为更小的部分。
    + 复合属性：将属性再划分为更小的部分（即其他属性）。
    + 单值属性：对一个特定实体，一个属性都只有**单独的一个值**。
    + 多值属性：对某个特定实体而言，一个属性可能对应于**一组值**（即一个属性可以取多个值）。

+ 联系集的类型：

  + 一对一，$A$ 中的一个实体**至多**与 $B$ 中的一个实体相关联，并且 $B$ 中的一个实体也至多与 $A$ 中的一个实体相关联。
  + 一对多，$A$ 中的一个实体可以与 $B$ 中的**任意数目（零个或多个）**实体相关联，而 $B$ 中的一个实体至多与 $A$ 中的一个实体相关联。
  + 多对一，$A$ 中的一个实体至多与 $B$ 中的一个实体相关联，而 $B$ 中的一个实体可以与 $A$ 中任意数目（零个或多个）实体相关联。
  + 多对多，$A$ 中的一个实体可以与 $B$ 中任意数目（零个或多个）实体相关联，而且 $B$ 中的一个实体也可以与 $A$ 中任意数目（零个或多个）实体相关联。

+ 映射基数（联系的基数）：

  ​	实体之间的联系的数量，即**一个实体**通过一个**联系**能与**另一实体集相关联的实体的数目**。

+ 实体集和二元联系集之间的一条边，可以有一个关联的**最大和最小的映射基数**。

  > 例如：
  >
  > ![image-20211004133238514](.\Database Systems.assets\image-20211004133238514.png)
  >
  > 一个 instructor 可以对应 **$0$ 个或多个** student，但一个 student **有且仅有一个** instructor，注意 advisor 联系是从 instructor 到 student的**一对多**联系。

+ 参与约束：

  + 完全参与联系：如果实体集 $E$ 中的**每个实体**都参与到联系集 $R$ 的**至少一个**联系中，此时最小基数为 $1$。
  + 部分参与联系：如果 $E$ 中只有**部分实体**参与到 $R$ 的联系中，此时最小基数为 $0$。

+ 弱实体集和强实体集：
  + 没有**足够的属性以形成主码**的实体集称作**弱实体集**（从属实体集）。
  + 有**主码**的实体集称作**强实体集**（独立实体集）。

### 3.2.数据库设计

+ 需求分析：

  ​	形成数据库设计的「源」清单和「属性」清单。

+ 概念数据库设计：

  + 用统一的表达方法，如 E-R 模型给出描述：

    + 各种实体的发现、划分和定义

    + 各种实体属性的发现、分析和定义
    + 各种实体联系的发现、分析和定义
    + 外部视图（模式）和概念视图（模式）的定义
  
  + 消除冲突：
  
    + 属性冲突：
      + 属性域的冲突（属性的类型、取值范围不同）
      + 属性取值单位冲突
    + 结构冲突：
      + 同一对象在不同应用中的抽象不同（职工在某应用中是实体，在另一应用中则抽象为属性）
      + 同一实体在不同 E-R 图中属性组成不同
      + 实体之间的联系在不同 E-R 图中呈现不同的类型
    + 命名冲突（同名异义，异名同义）
  
+ 逻辑数据库设计：

  + E-R 图转换为关系模式：

    + 一对一联系：

      + 若联系双方**均部分参与**，则将**联系**定义为一个**新的关系**，属性为参与双方的关键字（主码）属性。
      + 若联系**一方全部参与**，则将**另一方关键字**作为**全部参与方**的**属性**（即多一个属性），不需要联系集（感觉是 PPT 说反了）。

    + 一对多联系：

      ​	将**单方**（如教师和学生关系中的教师）参与实体的关键字，作为**多方**（学生）参与实体对应关系的属性。

    + 多对多联系：

      ​	将联系定义为**新的关系**，属性为参与**双方实体的关键字**。

  + 冗余（没懂）：

    + 受控冗余
    + 非受控冗余：存在传递函数依赖。

### 3.3.函数依赖

+ 函数依赖定义：

  + 设 $ {R}$ 是属性集合 $U=\left\{A_{1}, A_{2}, \ldots, A_{n}\right\}$ 上的一个关系模式，$X, Y$ 是**属性集** $U$ 上的两个**子集**。

  + 若对 $R$ 的任意关系 $r$，$  {r}$ 中**不可能有两个元组**满足在 $X$ 中的属性值相等而在 $Y$ 中的属性值不等，则称「$X$ 函数决定 $Y$」或「$Y$ 函数依赖于  $X$」，记作 $X \rightarrow Y$，称 $X$ 为决定因素，$Y$ 为依赖因素。

    > 关系模式是在属性集合上的结构化描述，关系是表状结构的。
    >
    > 函数依赖，顾名思义，$X$ 映射到 $Y$ ，同一个 $x$ 不会映射到两个 $y$。

+ 函数依赖的特性：
  
  + 如果 $Y\sub X$，则有 $X\to Y$。
  
  + 对 $ {X} \rightarrow  {Y}$，但 $ {Y} \not \subset  {X}$，则称 $X\rightarrow  {Y}$ 为**非平凡的函数依赖**。
  + 若 $X \rightarrow Y, Y \rightarrow X$，则记作 $X \leftrightarrow Y$。
  + 若 $Y$ 不函数依赖于 $X$. 则记作 $X \not\rightarrow Y$。
  + $ {X} \rightarrow  {Y}$，若是基于模式 $R$ 的，则对任意的关系 $r$ 成立；若仅基于具体关系 $ {r}$ 的，则可能只对该关系 $r$ 成立。
  + 如一关系 $r$ 的某属性集 $X$，$r$ 中**没有 $X$ 上相等的两个元组**，则 $ {X} \rightarrow  {Y}$ 恒成立。

+ 完全函数依赖和部分函数依赖：

  ​	在 $R$ 中，若 $X \rightarrow Y$ 并且对于 $X$ 的任何真子集 $X'$ 都有 $X'\not\rightarrow Y$，则称 $Y$ **完全（full）函数依赖**于 $X$，记为$X\stackrel{{f}}{\rightarrow} {Y}$，否则称 $Y$ **部分（partial）函数依赖**于 ${X}$，记为 ${X} \stackrel{{p}}\to {Y}$。

  >  $ {R}$ 是属性集合 $U$ 上的一个关系模式，若 $X\sub U$ 且 $X\stackrel{{f}}{\rightarrow} {U}$，则称 $X$ 为 $R$ 的**候选键**（候选码）。

+ 传递函数依赖：

  ​	在 $R$ 中，若 $X\to Y,Y \to Z$，其中 $Y\not\sub X,Z\not\sub Y,Z\not\sub X,Y\not\to X$（说明都是**非平凡依赖**），则称 $Z$ **传递函数依赖**于 $X$。 

+ 逻辑蕴涵：

  ​	设 $F$ 是关系模式 $R$ 的一个**函数依赖集合**， $X,Y$ 是 $R$ 的属性子集，若从 $F$ 的函数依赖能够推导出 $X \rightarrow Y$，则称 $F$ 逻辑蕴涵 $X \rightarrow Y$，记作 ${F} \models {X} \rightarrow{Y}$ 。

+ 闭包：

  ​	令 $F$ 为一个函数依赖集，$F$ 的**闭包**是被 $F$ **逻辑蕴涵的所有函数依赖**的集合, 记作 $F^{+}$。若 $F^+=F$，则 $F$ 是一个**全函数依赖族（函数依赖完备集）**。

  > 在下面的规则中去寻找逻辑蕴涵的函数依赖，通过反复应用这些规则，可以找到给定 $F$ 的全部 $F^{+}$。
  >
  > 用希腊字母 $(\alpha, \beta, \gamma, \cdots)$ 表示属性集，用 $\alpha \beta$ 表示 $\alpha \cup \beta_{\circ}$
  > 这组规则称为 Armstrong 公理：
  >
  > - 自反律：若 $\alpha$ 为一属性集且 $\beta \subseteq \alpha$，则 $\alpha \rightarrow \beta$ 成立。
  > - 增补律：若 $\alpha \rightarrow \beta$ 成立且 $\gamma$ 为一属性集，则 $\gamma \alpha \rightarrow \gamma \beta$ 成立。
  > - 传递律：$\alpha \rightarrow \beta$ 和 $\beta \rightarrow \gamma$ 成立，则 $\alpha \rightarrow \gamma$ 成立。
  >
  > 公理可导出的比较好用的引理：
  >
  > + **合并律**：若 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立, 则 $\alpha \rightarrow \beta \gamma$ 成立。 
  > + **分解律**：若 $\alpha \rightarrow \beta \gamma$ 成立, 则 $\alpha \rightarrow \beta$ 和 $\alpha \rightarrow \gamma$ 成立。 
  > + 伪传递律：若 $\alpha \rightarrow \beta$ 和 $\gamma \beta \rightarrow \delta$ 成立, 则 $\alpha \gamma \rightarrow \delta$ 成立（由 $\alpha \rightarrow \beta$ 得到 $\gamma\alpha \rightarrow \gamma\beta$，再由传递律得到结论）。

+ 属性集闭包：
  
  ​	对 $  {R}(  {U},   {F}),   {X} \subseteq   {U},   {U}=\left\{  {A}_{1},  {~A}_{2}, \ldots,   {A}_{ {n}}\right\}$，令：$  {X}^{+}_{F}=\left\{  {A}_{  {i}} \mid\right. 用Armstrong ~公理可从 F 导出 \left.  {X} \rightarrow   {A}_{  {i}}\right\}$ 称 $  {X}^{+}{ }_{ {F}}$ 为 X 于 $F$ 的**属性集闭包**。
  显然 $X \subseteq X^{+}{ }_{F}$。

  > 引理：$  {X} \rightarrow   {Y}$, 当且仅当 $  {Y} \subseteq   {X}_{  {F}}^{+}$ 。
  
+ 覆盖：

  ​	对 $R(U)$ 上的两个函数依赖集合 $F,G$，如果 $F^+= G^+$，则称 $F$ 和 $G$ 是**等价**的，也称 $F$ **覆盖** $G$ 或者 $G$ 覆盖 $F$。

+ 最小覆盖：

  ​	若 $F$ 满足以下条件，则称 $F$ 为**最小覆盖或最小依赖集**：

  + $F$ 中**每个函数依赖的右部是单个属性**。
  + 对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。
  + 对任何 $\{X\to A\} \in F$，$Z\sub X$，$(F- \{ X\to A \})\cup\{Z\to A\}$ 不等价于 $F$。

### 3.4.关系模式范式

+ 第一范式：

  ​	如果关系模式 $R$ 所有属性的域都是原子，则称 $R$ 属于第一范式（$1NF$）, 记作 $R \in 1NF$。

  > $1NF $ 要求关系中不能有复合属性、多值属性及其组合。
  >
  > 多值属性解决方案：
  >
  > ![image-20211005105615752](.\Database Systems.assets\image-20211005105615752.png)
  >
  > + 拆成两个表，原表去掉多值列，然后把多值属性和主码作为一个新的表。
  > + 拆成多行
  > + 拆成多列

+ 第二范式：

  ​	若 $R(U)\in 1NF$ 且 $U$ 中的每一**非主属性完全函数依赖**于**候选键**，则称 $R(U)$ 属于第二范式，记为：$R(U)\in 2NF$。

  > 第二范式消除非主属性对候选键的**部分依赖**。
  >
  > 将候选键拆成多个表，每个表的**非主属性**完全函数依赖于候选键。
  >
  > 第二范式只有历史意义，已经不在实际中使用了。

+ 第三范式：

  ​	在 $R$ 中若不存在**候选键** $X$，**属性集** $Y$，和**非主属性** $Z$，使得 $X\to Y,Y \to Z$ 成立，其中 $Y\not\sub X,Z\not\sub Y,Z\not\sub X,Y\not\to X$，则称 $R$ 属于第三范式，记为：$R\in 3NF$。

  > 第 $3$ 范式消除了**非主属性对侯选键的传递依赖**。
  >
  > 如满足第 $3$ 范式，则一定能满足第 $2$ 范式。

+ Boyce-Codd 范式：

  ​	若 $R(U,F)\in 1NF$, 若对于任何 $X\to Y\in F$（或 $X\to A\in F$），当 $Y\not\sub X$（或 $A\in X$）时，$X$ 必含有**候选键**，则称 $R(U)$ 属于 Boyce-Codd 范式，记为：$R(U)\in BCNF$。

  > 如满足 Boyce-Codd 范式，则一定能满足第 $3$ 范式。

+ 多值依赖：

  ​	对 $R(U)$，设 $X,Y\sub U$，若对于 $R(U)$ 的任一关系 $r$，若元组 $t\in r, s\in r,{t}[ {X}]= {s}[ {X}]$，则必有 $ {u} \in  {r},  {v} \in  {r}$ 使得：
  + $u[X]=v[X]=t[X]=s[X]$
  
  + $ {u}[ {Y}]= {t}[ {Y}]$ 且 $u[ {U}- {X}- {Y}]= {s}[ {U}- {X}- {Y}]$
  
  + $ {v}[ {Y}]= {s}[ {Y}]$ 且 $v[U- {X}- {Y}]= {t}[ {U}- {X}- {Y}]$
  
    | $X$  |  $Y$  | $U-X-Y$ |
    | :--: | :---: | :-----: |
    | $x$  | $y_1$ |  $z_1$  |
    | $x$  | $y_2$ |  $z_2$  |
    | $x$  | $y_2$ |  $z_1$  |
    | $x$  | $y_1$ |  $z_2$  |
  
  均成立，则称 $Y$ **多值依赖于** $X$，或说 $X$ **多值决定** $ {Y}$，记作 $ {X} \rightarrow \rightarrow  {Y}$，同时 $X \to\to U-X-Y$。
  
  > 若 $U=X\cup Y$ ，则一定有 $X\to\to Y$。
  >
  > 直观地，若 $ {X} \rightarrow \rightarrow  {Y}$，对于 $X$ 给定值，$Y$ 有一组值与之对应（$0$ 或 $n$ 个）且这组 $Y$ 值不以任何方式与 $U-X-Y$ 中属性值相联系。

+ 第四范式（基于多值依赖的 BCNF 范式）：

  ​	函数依赖和多值依赖集为 $F$ 的关系模式 $R(U)$ 属于第四范式 $(4  {NF})$ 的条件是，对 $F^{+}$中所有形如 $\alpha \rightarrow \beta$ 的多值依赖（其中 $\alpha \subseteq 	U$ 且 $\beta \subseteq U$），至少有以下之一成立：

  - $\alpha \rightarrow \beta$ 是一个平凡的多值依赖。
  - $\alpha$ 是 $R$ 的一个超码。

### 3.5.模式分解

+ 模式分解定义：

  ​	关系模式 $R(U)$ 的分解是指用 $R$ 的一组子集 $\rho=\left\{ {R}_{1}, \ldots,  {R}_{ {k}}\right\}$ 来代替它。其中 $ {U}= {U}_{1} \cup  {U}_{2} \cup \ldots \cup  {U}_{ {k}},{U}_{ {i}} \notin  {U}_{ {j}}( {i} \neq  {j})$ 。对于关系模式 $R$ 的任一关系 $r$，它向 $\rho$ 的投影连接记为 $ {m}_{\rho}( {r})$ :
  $$
  {m}_{\rho}( {r})=\pi_{ {R}_{1}}( {r}) \bowtie \ldots \bowtie \pi_{ {R}_{ {k}}}( {r})=\bowtie_{( {i}=1, \ldots,  {k})} \pi_{ {R}_{ {i}}}( {r})
  $$
  这里 : $\pi_{ {R}_{ {i}}}( {r})=\left\{ {t}\left[ {R}_{ {i}}\right] \mid  {t} \in  {r},  {i}=1, \ldots,  {k}\right\}$。
  
  > 若对关系模式 $R$ 的任一关系 $r$ 都有 $r = m_\rho(r)$ 成立，则称 $\rho$ 是 $R$ 相对于 $F$ 的一个**无损连接分解**。
  
+ 无损连接分解检验算法：

  + 构造一 $k$ 行 $n$ 列的表（$k$ 是分解的集合数，$n$ 是 $R(U)$ 属性数），可称为 $ {R}_\rho$ 表。
  + 其中第 $j$ 列对应于 $ {A}_{ {j}}$，第 $i$ 行对应于 $ {R}_{ {i}}$。
  + 若 $ {A}_{ {j}} \in  {R}_{ {i}}$，则 $ {R}_{\rho}$ 表中第 $i$ 行第 $j$ 列位置填写符号 $ {a}_{ {j}}$，否则填写 $ {b}_{ {ij}}$ 。
  + 根据 $\forall( {X} \rightarrow  {Y}) \in  {F}$，对 $ {R}_{\rho}$ 表进行修改：给定 $ {X} \rightarrow  {Y}$，寻找 **$X$ 属性取值相同**的行，用其值重置 $Y$ 属性值（$a$ 或 $b$，其实相当于归为一个并查集里）。
  + 修改后，如果有一行变成 $ {a}_{1},  {a}_{2}, \ldots,  {a}_{ {n}}$，则 $\rho$ 是无损连接分解，否则为有损连接分解。
  
  > 对于分解成两个子集的情况，可以快速判断的方法：
  >
  > + 设 $F$ 是关系模式 $R$ 上的一个函数依赖集合，$\rho=\left\{ {R}_{1},  {R}_{2}\right\}$ 是 $R$ 的一个分解。
  >
  > + 则当且仅当 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{1}- {R}_{2}$ 或者 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{2}- {R}_{1}$ 属于 $F^+$ 时，$\rho$ 是关于$F$ 无损连接的。
  >
  > + 因为 $R_1=(R_1\cap R_2) \cup(R_1-R_2),R_2=(R_1\cap R_2) \cup(R_2-R_1)$，所以有
  >
  >   |       | $R_1\cap R_2$ | $R_1- R_2$ | $R_2- R_1$ |
  >   | :---: | :-----------: | :--------: | :--------: |
  >   | $R_1$ |     $a_1$     |   $a_2$    |  $b_{13}$  |
  >   | $R_2$ |     $a_1$     |  $b_{22}$  |   $a_3$    |
  >
  > + 此时只要 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{1}- {R}_{2}$ 或者 $ {R}_{1} \cap  {R}_{2} \rightarrow  {R}_{2}- {R}_{1}$ 属于 $F^+$ 的一个成立，就能实现有一行变成 $ {a}_{1},  {a}_{2},{a}_3$。
  
+ 保持依赖分解的分解：

  + 对于关系模式 $R( {U},  {F})$，${U}$ 是属性全集，$F$ 是函数依赖集合，$\rho=\left\{ {R}_{1}, \ldots,  {R}_{ {k}}\right\}$ 是 $R$ 的一个分解。
  + 如在 $\pi_{ {R_i}}( {F})$ 中的所有依赖之并集 $( {i}=1, \ldots,  {k})$，**逻辑蕴涵 $F$ 的每个依赖**，则称分解 $\rho$ 保持依赖集 $F$。
  + 其中 $\pi_{ {R_i}}( {F})$ 是 $F$ 在 $ {R}_{ {i}}$ 上的投影，即 $F$ 中的任一投影 $ {X} \rightarrow  {Y}$，如果 $X,Y\in R_i$，则 $ {X} \rightarrow  {Y} \in \pi_{ {R_i}}( {F})$。

+ 保持依赖分解检测算法：

  > 对 $F$ 中的每一个 $\alpha \rightarrow \beta$，
  > $result =\alpha$
  > $while$
  > 		$for ~each$ 分解后包含有 $\alpha$ 的 $R_{i}:$
  > 				$t=\left( result \cap R_{i}\right)^{+} \cap R_{i}$
  > 				$result = result \cup t$
  > $until ~(~result$ 没有变化 $)$ 
  >
  > 如果 $result$ 含 $F$ 中的所有属性，则函数依赖 $\alpha\to \beta$ 保持。

+ BCNF 分解 + 无损连接分解：

  > BCNF 范式要求每个函数依赖的左侧都要是关系模式的**超键**。

  + 仅 BCNF 分解：

    ​	将左侧不含候选键的函数依赖**单独组成一个关系**，将包含候选键的组成一关系。

  + 无损连接分解成 BCNF：

    > 计算 $F^{+}$
    > $while ~(~result \not\in BCNF~)~ do:$
    > 		$if (result$ 中存在模式 $R_{i}$ 不属于 $BCNF )$
    > 				对于 $R_{i}$ 上所有非平凡函数依赖 $\alpha \rightarrow \beta$ （ 满足 $\alpha \rightarrow R_{i}$ 不属于 $F^{+}$，即 $\alpha$ 不是 $R_i$ 的超键）
    > $\quad$ 					 $result =\left(\right. result \left.-R_{i}\right) \cup\left(R_{i}-\beta\right) \cup(\alpha, \beta) $ （即用两个模式 $\left(R_{i}-\beta\right) \cup(\alpha, \beta)$ 取代原来的 $R_i$，由之前的快速判断的方法可知分解无损） 

+ $3NF$ 分解 + 保持依赖分解（+ 无损连接分解）：

  + 仅 $3NF$ 分解：

    ​	将每一个函数依赖单独组成一个关系。

  + 持依赖分解成 $3NF$：

    + 关系模式 $R(U, F)$，$F$ 是函数依赖集**最小覆盖**，$\rho$ 为所求分解。

    + 若有 $ {X} \rightarrow  {A}_{1},  {X} \rightarrow  {A}_{2}, \ldots,  {X} \rightarrow  {A}_{ {m}}\in{F}$，则以 $ {XA}_{1}  {~A}_{2} \ldots  {A}_{ {m}}$ 组成一模式 $R_i$，$\rho=\rho\cup R_i$

      > 因为 $F$ 是最小覆盖，要求对任何 $\{X\to A\}\in F$，有 $F- \{ X\to A \}$ 不等价于 $F$。
      >
      > 所以一定不会存在 $A_i\to A_j\in F(i\not=j)$ 的情况，否则 $F-\{X\to A_j\}$ 仍等价于 $F$。

    + 上一步处理完后，把 $R$ 中不出现在 $F$ 中的属性去掉并单独组成一模式。

      > 如果这一模式存在，将这个模式加上候选键属性，则能使该分解达到无损。
      >
      > 如果并不存在，则判断所得 $\rho$ 集合中的是否存在一个 $R_i$ 包含了属性集。如果不存在，则给 $\rho$ 并上候选键属性集达到无损分解。

## 4.数据存储和查询

### 4.1.存储和文件结构

+ 存储体系：

  + 将不同性价比的存储器组织在一起，满足高速度、大容量、低价格需求。
  + CPU 与内存直接交换信息，按存储单元（存储字）进行访问。
  + 外存按**存储块**进行访问，其信息需先装入**内存**，才能被 CPU 处理。

+ 操作系统对数据的组织：

  + FAT（文件分配表 - File Allocation Table）- 目录（文件夹）- 磁盘块/簇

    <img src=".\Database Systems.assets\image-20211012225110095.png" alt="image-20211012225110095" style="zoom:67%;" />

  + 对于一个文件，用 FAT 找到它在磁盘中的位置。

+ 内存管理：

  ​	一条记录的地址 = 存储单元的地址 = 内存地址 = 页面：页内偏移量

+ 磁盘结构：

  <img src=".\Database Systems.assets\image-20211012161544352.png" alt="image-20211012161544352" style="zoom: 67%;" />

  + **盘片**的表面从逻辑上划分为**磁道**（同心圆），磁道又划分为**扇区**。
  + 扇区是从磁盘读出和写入信息的**最小单位**，系统数据传输的基本单位是磁盘块（几个连续的扇区）。
  + 一个磁盘的基本信息：
    + $8$ 个圆盘，$16$ 个盘面
    + 每个盘面有 $2^{16}$ 或 $65536$ 个磁道
    + 每个磁道（平均）有 $2^{8}=256$ 个扇区
    + 每个扇区有 $2^{12}=4096$ 个字节
    + 磁盘的容量 $=2^{4 }\times 2^{16} \times 2^8 \times 2^{12}=2^{40}$ 字节

+ 磁盘数据读写时间：

  + 包括寻道时间（约在 $1-20ms$），旋转时间（约 $0-10ms$）和传输时间。

  + 磁盘以 $7200$ 转/$min$ 旋转，即 $8.33ms$ 内旋转一周

  + 柱面之间移动磁头组合从启动到停止花费 $1 ms$。

  + 每移动 $4000$ 个柱面另加 $1ms$，即磁头在 $0.00025 ms$ 内移动一个磁道，从最内圈移动到最外圈，移动 $65536$ 个磁道大约用 $0.00025\times 65536 + 1=17.38ms$。

  + 一个磁道中扇区间的空隙大约占 $10 \%$ 的空间 

  + 一个磁盘块 $=4$ 个扇区 $=16384$ 个字节

  + 最短时间 $=$ 传输时间大约是 $0.13ms$

  + 最长时间 $=$ 寻道时间+旋转时间+传输时间 $=17.38+8.33+0.13=25.84 m s$

  + 平均时间 $=6.46(16.38/3+1)+4.17(8.33/2)+0.13=10.76 ms$ 

    > 括号中的表达式指出这个数是怎么得到的。
    >
    > 平均寻道时间要除以 $3$ 是求了一个盘片内径向任意两点之间移动时间的期望（前提假定为平均分布）。
    >
    > 设盘片半径为 $r$。令 $f(y)=|x-y|$，即表示径向从 $y$ 点到 $x$ 点之间距离。
    >
    > 当 $x$ 为 $[0,r]$ 上的固定值时，求出 $[0,r]$ 上所有点到 $x$ 的期望距离：
    > $$
    > \mathbb{E}f(y)=\int^r_0|x-y|\frac{1}{r}dy=\frac{x^2}{r}-x+\frac{r}{2}
    > $$
    > 对于所有 $x\in[0,r]$，计算期望距离的期望：
    > $$
    > \mathbb{E}\mathbb{E}f(y)=\int^r_0\frac{1}{r}(\frac{x^2}{r}-x+\frac{r}{2})dx=\frac{r}{3}
    > $$
    > 即磁头平均会移动 $\begin{aligned}\frac{r}{3}\end{aligned}$。
    
  + 物理存取算法考虑的关键：

    + 降低 I/O 次数。
    + 降低排队等待时间。
    + 降低**寻道/旋转**延迟时间：
      + 同一**磁道**连续块存储
      + **同一柱面**不同磁道**并行**块存储
      + 多个**磁盘**并行块存储

+ 独立磁盘冗余阵列（Redundant Array of Independent Disk, RAID技术）（理解）：

  + 块级拆分：

    ​	一个文件由多个块组成，不同**块**存储于不同磁盘。

  + 比特级拆分：

    ​	一个字节被拆分成 $8$ 个比特位, 不同**比特位**存储于不同磁盘。

  + RAID $0$ 级：

    ​	块级拆分但**没有任何冗余**（例如镜像或奇偶校验位）的磁盘阵列。

  + RAID $1$ 级：

    ​	使用块级拆分的磁盘**镜像**，每一个磁盘有一个镜像磁盘。

  + RAID $2$ 级：

    ​	位交叉纠错处理，$4$ 个磁盘存储 $4$ 位 $+~3$ 个校验盘存储 $3$ 校验位。

  + RAID $3$ 级：

    ​	RAID $2$ 级的改进，只用一个校验盘，比 RAID $2$ 级常用。

  + RAID $4$ 级：

    ​	块交叉的奇偶校验组织结构。它像 RAID $0$ 级一样使用块级拆分，此外在一张**独立的磁盘**上为其他 $N$ 张磁盘上对应的块保留一个**奇偶校验块**。

  + RAID $5$ 级：

    ​	块交叉的**分布奇偶校验位**的组织结构，是 RAID $4$ 级的改进，将数据和奇偶校验位都分布到所有的 $N + 1$ 张磁盘中。

    <img src=".\Database Systems.assets\image-20211013151334886.png" alt="image-20211013151334886" style="zoom:67%;" />

+ 数据存储的映射：

  <img src=".\Database Systems.assets\image-20211013152301903.png" alt="image-20211013152301903" style="zoom:80%;" />

+ 数据库记录在磁盘上的存储：

  + 定长记录（根据偏移量区分记录）：

    ​	所有字段固定位数（黑色是空着的）。

    ![image-20211013185732990](.\Users\lenovo\Desktop\Database Systems\Database Systems.assets\image-20211013185732990.png)

  + 变长记录（靠分隔符区分开始与结束）：

    + 块头包括：
      + 块头中记录条目的个数。
      + 块中空闲空间的末尾处。
      + 一个由包含记录**位置和大小**的记录条目组成的数组。

    + 实际记录从块的**尾部**开始连续排列。

    + 块中**空闲空间是连续**的，无论是插入操作还是删除操作都不能改变这一点。

    + 如果插入一条记录，在**空闲空间的尾部**给这条记录分配空间，并且将包含这条记录大小和位置的条目添加到块头中。 

    + 如果一条记录被删除，它所占用的空间被释放，并且它的条目被设置成被**删除状态**，此外，块中在被删除记录之前的记录将被移动，使得由删除而产生的空闲空间被重用，并且所有空闲空间仍然保持连续。块头中的空闲空间末尾指针也要做适当修改。

      > 移动记录的代价并不高，因为块的大小是有限制的，典型的值为 $4-8$KB。

    ![image-20211013185940477](.\Database Systems.assets\image-20211013185940477.png)

+ 数据库 - 表所占磁盘块的分配方法：

  + 连续分配: 数据块被分配到连续的磁盘块上（会存在**扩展困难**问题）。

  + 链接分配: 数据块中包含指向下一数据块的指针（**访问速度**问题），不连续，有空位就放。

  + 按簇分配: 按簇分配，簇之间靠指针连接，簇有时也称**片段**，结合前面两者优点。

  + 索引分配: 索引块中存放指向实际**数据块的指针**（可以不用 FAT）。

    <img src=".\Database Systems.assets\image-20211013191826059.png" alt="image-20211013191826059" style="zoom:80%;" />

+ 文件组织方法：

  + 无序文件组织：

    + 无序记录文件（堆文件 heap 或 pile file）

    + 记录可存储于任意有空间的位置，磁盘上存储的记录是无序的。**更新效率高**，但**检索效率可能低**。

    + 一开始新记录总插入到文件尾部。删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记「**删除标记**」，新增记录可以利用那些标记为「删除标记」的记录空间

    + 频繁删增记录时会造成空间浪费，所以需要周期性**重新组织数据库**。

      > 数据库重组是通过移走被删除的记录使**有效记录连续存放**，从而回收那些由删除记录而产生的未利用空间。

  + 有序文件组织

    + 有序记录文件（排序文件 Sequential）

    + 记录按某属性或属性组值的顺序插入，磁盘上存储的记录是有序的。**检索效率可能高**。

    + 用于存储排序的属性通常称为**排序字段**，可以是关系中的**主码**，所以又称**排序码**。

    + 当按排序字段进行检索时，速度得到很大提高。但当按非排序字段检索时，速度可能不会提高很多。

    + 改进办法（使用溢出）：

      + 为将来可能插入元组预留空间（这可能造成空间浪费），或使用一个**临时的无序文件**（被称为**溢出文件**）保留新增的记录。

      + 当采取溢出文件措施时，检索操作既要操作主文件，又要**操作溢出文件**。

      + 需要周期性**重新组织数据库**。

        > 数据库重组将溢出文件**合并**到主文件，并恢复主文件中的记录顺序。

  + 散列文件组织

    + 散列文件（Hash file）
    + 可以把记录按某属性或属性组的值，依据一个**散列函数**来计算其应存放的**位置（桶号）**，检索效率和更新效率都有一定程度的提高。
    + 用于进行散列函数计算的属性通常称为**散列字段**，散列字段通常也采用关系中的**主码**，所以又称**散列码**。
    + 不同记录可能被hash成同一桶号，此时需在桶内顺序检索出某一记录。

  + 聚簇文件组织：

    + 聚簇文件（Clustering file）
    + **聚簇**：将具有**相同或相似属性值**的记录存放于**连续**的磁盘簇块中，优化连接代价，在**不用索引**的时候使用。
    + 多表聚簇：将若干个**相互关联**的表存储于一个文件中，可提高多表情况下的查询速度。
    + 何时使用多表聚簇依赖于数据库设计者所认为的**最频繁的查询类型**。

### 4.2.索引概念和分类

+ 索引定义：

  + 定义在存储表基础上，无需检查所有记录，快速定位所需记录的一种辅助存储结构，由**一系列**存储在**磁盘**上的**索引项**组成，每一索引项又由两部分构成:
    + **索引字段**：

      ​	由表中**某些列**中的值串接而成，类似于词典中的词条。索引中**通常**存储了索引字段的每一个值。

    + 行指针：

      ​	指向表中包含索引字段值的记录在磁盘上的**存储位置**，类似于词条在书籍、词典中出现的页码。

  + 有索引时，更新操作必须**同步更新**索引文件和主文件。

  + **连接条件、分组**计算条件中的属性可建立索引。

  > 存储**索引项**的文件为**索引文件**，存储表称为**主文件**。

+ 索引文件组织方式有两种：

  + **排序索引文件**：

    ​	按**索引字段值**的某一种**顺序**组织存储。

  + **散列索引文件**：

    ​	依据**索引字段值**使用**散列函数**分配散列桶的方式存储。

  > 主文件组织有堆文件、排序文件、散列文件、 聚簇文件等多种方式，和索引文件区分。

+ 索引应用的评价：
  + 访问时间：
  
    ​	在查询中使用该技术找到一个特定数据项或数据项集所需的时间
  
  + 插入时间：
  
    ​	插入一个新数据项所需的时间。该值包括**找到**插入这个新数据项的正确位置所需的时间，以及**更新**索引结构所需的时间。 
  
  + 删除时间：
  
    ​	删除一个数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。 
  
  + 空间开销：
  
    ​	索引结构所占用的额外存储空间。倘若存储索引结构的额外空间大小适度，通常牺牲一定的空间代价来换取性能的提高是值得的。

+ 码的区分：

  + 排序码：

    ​	对主文件进行排序存储的那些属性或属性组。

  + 索引码：

    ​	即索引字段，**不一定具有唯一性**。

  + 搜索码：

    ​	在文件中**查找记录的属性或属性集**称为**搜索码**。

+ 稠密索引：
  + 主文件中每一个**搜索码值**都有一个索引项和它对应。

  + 对候选键建稠密索引：主文件不用排序，直接可以定位。

  + 非候选键建稠密索引：

    + **索引文件**中索引字段值是**不重复的**，**主文件**按索引字段**排序**。

    + **索引文件**中索引字段值是有**重复**的，主文件**不排序**。

    + 引入**指针桶**处理非候选键索引的多记录情况，**索引文件**中索引字段值是**不重复的**，主文件**不排序**。

      <img src=".\Database Systems.assets\008i3skNgy1gtond7hy0hj60h30boq3y02.jpg" alt="image-20211013191826059" style="zoom:80%;" />

+ 稀疏索引：

  ​	稀疏索引只为主文件**部分搜索码值**建立索引记录，**主文件**按索引字段**排序**。

+ 主索引：

  + 如果包含记录的文件按照某个**搜索码**指定的顺序**排序**，那么该搜索码对应的索引称为聚集索引，也称为**主索引**。
  + 主索引对每一**存储块**有一个**索引项**，索引项的总数和存储表所占的存储块数目相同。
  + 存储表的每一存储块的第一条记录，又称为**锚记录**，或简称为块锚。
  + 主索引可以是**稀疏索引**。

+ 辅助索引：

  + 辅助索引定义在**主文件**的任一或多个**非排序字段**上的辅助存储结构。
  + 辅助索引一定是稠密索引。

  > 一个主文件仅可以有一个主索引（只按主索引的搜索码排序），但可以有多个辅助索引。

+ 聚簇索引：

  + 聚簇**索引**定义：

    ​	聚簇索引是指**索引中邻近**的记录在**主文件**中也是临近存储的。

  + 聚簇**字段**定义：

    ​	如果主文件的某一**排序**字段**不是主码**，则该字段上每个记录取值便不唯一，此时该字段被称为**聚簇字段**。聚簇索引通常是定义在聚簇字段上。

+ 非聚簇索引：

  ​	指索引中邻近的记录在主文件中不一定是邻近存储的。

  > + 一个主文件只能有一个聚簇索引文件，但可以有多个非聚簇索引文件。
  > + 主索引通常是聚簇索引（但其**索引项**总数**不一定**和主文件中**聚簇字段**上不同值的数目相同，其和主文件存储块数目相同）。
  > + 辅助索引通常是非聚簇索引。
  > + 主索引/聚簇索引是能够**决定记录存储位置**的索引；而非聚簇索引则只能用于**查询**，指出已存储记录的位置。

### 4.3.多级索引（B+ 树）

> 当索引项比较多时，可以对索引再建立索引，依此类推，形成多级索引。

+ B+ 树节点：

  ![image-20211014210434101](.\Database Systems.assets\image-20211014210434101.png)

  + $K_i$：索引字段值

  + $P_i$​：

    + 是指向 **索引块**或**数据块**或数据块中记录 的指针。

      > 非叶结点指针指向**索引块**，叶结点指针指向主文件的数据块（稀疏索引）或数据记录（稠密索引）。

    + 每个索引块的**指针利用率**都在 **$50\%-100\%$** 之间。

    + 索引字段值 $x$ 在 $K_{i-1}\le x<K_i$ 的由 $P_i$ 指向（设 $K_0=0$），而 $K_i\le x<K_{i+1}$ 的由 $P_{i+1}$ 指向。

    + $P_n$ 指向下一个叶节点。

+ B 树和 B+ 树比较：
  + B树索引字段值**仅出现一次**，可以在叶结点或者在非叶结点；B+ 树有重复索引字段值。
  + 指向主文件的**指针**出现于**叶结点或非叶结点**，另一个指针指向结点；B+ 树只有叶子结点有指向主文件的指针。
  + **所有结点才能覆盖**所有键值的**索引**；B+ 树叶子结点就能覆盖。
+ B+ 树插入：
  + 当索引块充满时，需要分裂，分裂后也要保证指针利用率不低于一半。
  + 分裂可能引发连锁反应，由**叶结点直至根结点**判断。
  + 分裂后需要仔细调整索引**键值及指针**。
  + 注意**叶子结点之间**链接关系的调整。
+ B+ 树删除：
  + 当删除后指针利用率低于一半，先考虑从相邻叶子结点借索引项，如果不能借就合并。
  + 合并可能引发连锁反应，由叶结点直至根结点。
  + 合并后需要仔细调整索引键值及指针。
  + 注意叶子结点之间链接关系的调整。

### 4.4.散列索引

+ 桶：

  ​	表示能存储一条或多条记录的一个存储单位。

+ 散列函数：

  ​	$K$ 表示所有搜索码值的集合，令 $B$ 表示所有桶地址的集合，散列函数 $h$ 是一个从 $K$ 到 $B$ 的函数。

  > 散列函数要满足分布是**均匀的**和随机的。

+ 溢出桶：

  ​	如果一条记录必须插入桶 $b$ 中，而桶 $b$ 已满，系统会为桶 $b$ 提供一个**溢出桶**，并将此记录插入到这个溢出桶中。

+ 静态散列索引的缺点：

  ​	如果桶的数目 $M$ 不变，过大则**浪费**；过小则将产生更多的**溢出桶**，增加散列索引检索的时间。

+ 可扩展散列索引：

  + 有一个附加的间接层（**指针数组**），系统在访问桶本身（数据块）之前必须先访问指针数组表。

  + 指针数组能增长，其长度总是 $2$ 的幂。因而数组每增长一次，桶的数目就翻倍。某些桶可能共享一个块。

  + 参数 $k$ 表示散列函数所可能使用的**最多位数**。

  + 散列函数：

    ​	散列函数 $h$ 为每个键计算出一个 **$k$ 位二进制序列**（散列函数值）。

  + $i$ 为散列函数当前已经使用到的最多位数。取散列函数值的前 $i$ 位（散列前缀）为作为要插入桶的编号。

  + 插入某个桶时发现已满，则需要扩展散列桶，进行分裂：

    + $i$ 增 $1$，重新散列该块的数据到**两个块**中。
    + 其他的桶按照散列前缀重新指向对应数据块，可能出现多个桶共享一个块的情况。

  > 缺点：
  >
  > + 翻倍要处理的工作量很大。
  > + 桶数翻倍后，主存可能装不下。
  > + 可能产生大量空间浪费，因为很多块可能都没有存多少数据，就因为一个桶满了得翻倍。

+ 线性散列索引：

  + 桶数的选择：

    ​	保持与存储块所能容纳的记录总数成一个**固定的比例**，例如 $80\%$。超过此比例，则桶数**仅增长 $1$ 块**。不超过这个比例时允许有溢出桶。

  + 假定散列函数值的 $i$ 位为桶数组项编号。现在要插入一个键值为 $K$ 的记录：

    + 通过散列函数得知要插入编号为 $a_{1} a_{2} \ldots a_{i}$ 的桶中，即 $a_{1} a_{2} \ldots a_{i}$ 是 $h(K) $ 的后 $i$ 位。设 $m=a_{1} a_{2} \ldots a_{i}$，$n$ 为当前的桶数。

    + 如果 $m<n$，则编号为 $m$ 的桶存在，并把记录存入该桶中。

    + 如果 $n \leq m<2^{i}$，那么桶还不存在，因此我们把记录存入桶 $m-2^{{i}-1}$，也就是当我们**把 $a_{1}$（它现在是 $1$)改为 $0$ 时对应的桶**。

    + 如果插入后不满足比例时，要分裂一个桶成两个，这个要分裂的桶的编号是这样确定的：

      ​	设当前 $n$ 已增一，则分裂与 $n$ **低位相同**而**最高位不同**的那一个桶，即假设该桶为 $1a_2a_3\cdots a_i$，则该桶由 $0a_2a_3\cdots a_i$ 对应的块分裂而来。

    + 分裂只会影响分裂之后的两个桶的记录，其他保持不变。

    + 当桶数超过 $2^i$ 个桶时，则使 $i$ 增 $1$。

## 5.数据库查询实现算法

### 5.1.概述

+ 查询优化：

  ​	构造具有最小查询执行代价的查询执行计划应当是系统的责任，这项工作叫作查询优化。

+ 逻辑层优化：

  ​	优化关系代数操作执行次序。

+ 物理层优化：

  ​	优化关系代数操作实现算法。

  > 为每一个关系代数操作选择优化的执行**例行程序**，形成**物理查询计划**。

+ 物理层优化的查询实现：

  + DBA 获取数据库的相关信息（**定期统计**）。
  + 选择相应操作的例行程序
  + 依据相关信息进行代价估算，并选择代价最少的例行程序及确定相应的参数。
  + 形成查询计划：以基本的例行程序为基本步骤，确定这些例行程序的执行顺序。

+ 一次单一元组的一元操作（选择和投影）：

  ​	$\sigma_{F}(R), \pi_{\alpha}(R)$ 

+ 整个关系的一元操作：

  ​	$\delta(\mathrm{R}),\rm DISTINCT; \gamma(\mathrm{R}), GROUP BY;\tau(\mathrm{R}),SORTING$ 

+ 整个关系的二元操作：

  + 集合（包：允许重复）上的操作: $\cup_{\mathrm{S}}, \cap_{\mathrm{S}},-\mathrm{S}$
  + 积，连接：PRODUCT， JOIN

### 5.2.连接操作的实现算法

+ 关系的物理存储相关的参数：

  > 关系是存储在**磁盘**上的，磁盘是以**磁盘块为操作单位**，首先要被装载进**内存**（I/O 操作），然后再进行元组的处理。

  + $\mathrm{T}_{\mathrm{R}}$：关系 R 的**元组数目**。

  + $\mathrm{B}_{\mathrm{R}}$：关系 R 的**磁盘块**数目。

  + $ \mathrm{M}$：**主存**缓冲区的页数（主存每页容量等于一个磁盘块的容量）。

  + $\mathrm{I}_{\mathrm{R}}$：关系 R 的每个**元组的字节数**。

  + $b$：每个**磁盘块的字节数**。
    $$
    \mathrm{B}_{\mathrm{RxS}}=\mathrm{T}_{\mathrm{R}} \mathrm{T}_{\mathrm{S}}\left(\mathrm{I}_{\mathrm{R}}+\mathrm{I}_{\mathrm{S}}\right) / \mathrm{b}
    $$

+ I/O 操作所需时间远大于内存操作，下面仅考虑 I/O 用时（次数），且为定长记录块，忽略写回结果。

+ 连接操作算法 $P_1$（主存利用率低）：

  ```c
  /* I/O 操作 */
  For i = 1 to BR
  	read i-th block of R       // 执行 BR 次
  	For j = 1 to BS
  		read j-th block of S   // 执行 BR * BS 次
      
      	/* 内存操作 */
  		For p = 1 to b/IR     // 取元组
  			read p-th record of R
  			For q = 1 to b/IS
  				read q-th record of S
  			if R.A 关系 S.B then
  				串接 p-th record of R和q-th record of S;存入结果关系
  ```

  I/O 次数估计为 $B_R + B_R\times B_S$

+ 连接操作的全主存实现算法 $P_2$：

  ```C
  /* 算法假定内存大小 M >= BR + BS，即只需要读一遍关系 R 和 S 的磁盘块 */
  For i = 1 to BR 
  	read i-th block of R
  For j = 1 to BS 
  	read j-th block of S
  /* 内存操作同 */
  ```

  I/O 次数估计为 $B_R + B_S$

+ 连接操作的半主存实现算法 $P_3$：

  ```c
  /* 算法假定内存大小min(BR,BS) < M < BR + BS，这里假设较小的是 BR，读一次 R 的磁盘块放内存，S 的每次读就处理，不用全部放入内存再处理 */
  For i = 1 to BR 
  	read i-th block of R
  For j = 1 to BS //一次读入一块关系 S 的磁盘块
  	read j-th block of S
  	/* 内存操作同 */
  ```

  I/O 次数估计为 $B_R + B_S$

+ 连接操作的大关系实现算法 $P_4$：

  ```c
  /* 把关系 S 划分为 BS/(M-2) 个子集合，每个子集合具有 M-2 块。令 MS 为 M-2 块容量的主存缓冲区，
  * MR 为 1 块容量的 R 的主存缓冲区，还有 1 块作为输出缓冲区。
  */
  For i = 1 to BS/(M-2) //一次读入M-2块
  	read i-th Sub-set of S into MS      // 执行 BS/(M-2) 次,总共 BS 次 I/O   
  	For j = 1 to BR //一次读入一块
  		read j-th block of R into MR    // 执行 BS/(M-2) * BR 次
  		For p = 1 to (M-2)b/IS
  		/* 内存操作同 */
  ```

  I/O 次数估计为 $B_R(B_S /(M-2)) + B_S$（将主存充分利用）。

### 5.3.一趟扫描算法

+ 关系 $R$ 数据读取：

  > $B(R)$ 是 $R$ 的**存储块**（磁盘块）数目
  > $T(R)$ 是 $R$ 的**元组**数目

  + 聚簇关系：

    > 指关系的元组集中存放（一个块中仅是一个关系中的元组）。

    + TableScan(R) 为表空间扫描算法
      扫描结果未排序：$B(R)$

    + SortTableScan(R)
      扫描结果**排序**：$B(R)~or~ 3B(R)$

      > 内存装得下 $R$ 就只需要 $B(R)$，否则需要 $3B(R)$。

    + IndexScan(R) 为索引扫描算法
      扫描结果未排序：$B(R)$

    + SortIndexScan(R)
      扫描结果排序: $B(R)~or~ 3B(R)$

  + 非聚簇关系：

    > 关系的元组不一定集中存放（一个块中不仅是一个关系中的元组）。

    + 扫描结果未排序：$T(R)$
    + 扫描结果排序：$T(R) + 2B(R)$

+ 去重复：$\&(R)$
  + 在**内存中保存**已处理过的元组。
  + 当新元组到达时，需与之前处理过的元组进行比较。
  + 建立不同的**内存数据结构**（排序结构/散列结构/B+ 树），来保存之前处理过的数据，以便快速判断是否重复。
  + 算法复杂性：$B(R)$
  + 应用条件：$B(\&(R))\le M$

+ 分组聚集 $\gamma _L(R)$

  + 需要在内存中保存所有的分组，保存每个分组上的聚集信息。

  + 建立不同的内存数据结构（排序结构/散列结构/B+ 树），来保存之前处理过的数据，以便快速处理整个关系上的操作。
  + 算法复杂性：$B(R)$
  + 应用条件：所有分组的数量应能在内存中完整保存。

+ 集合或者包上的并交叉运输（二元）：
  + **扫描一个关系** $R$，然后**再扫描另一个关系** $S$
  + 集合的操作需要去重复。包的操作需要做计数每个元组的出现次数（具体操作还需具体分析）
  + 算法复杂性：$B(R)+B(S)$
  + 应用条件：$min(B(R), B(S))\le M$（只要用一个能放入内存就行）

+ 连接操作实现算法 $P4$ 的改进：
  + 主要思想就是把内存操作的两重循环通过散列的方式，压缩到一重循环就行。
  + 散列函数可取连接条件中的相应属性，使得**散列结果相同说明这两个属性满足连接条件**。

### 5.4.基于索引的选择算法

+ **选择**条件中有涉及到**索引属性**时，可以使用索引，辅助快速检索。

+ 聚簇和非聚簇索引，使用时其效率是不一样的。

+ 案例分析：

  + 假设 $B(R)=1000, T(R)=20000$，即：$R$ 有 $20000$ 个元组存放到 $1000$ 个块中。

  + $a$ 是 $R$ 的一个属性，在 $a$ 上有一个索引，并且考虑 $\sigma_{a=0}(R)$ 操作：

    + 如果 $R$ 是**聚簇**的，且**不使用索引**，查询代价 $=~1000$ 个 I/O。

      > 一个块中仅是一个关系中的元组，所以最多遍历 $1000$ 次磁盘块就能找到所以元组。

    + 如果 $R$ **不是聚簇**的，且**不使用索引**，查询代价 $=~20000$ 个 I/O 。

      > 一个块中不仅是一个关系中的元组，可能含有其他数据，必须通过元组的指针进行遍历，所以要访问 $20000$ 个元组，考虑最坏情况，相邻元组都不在同一个块，那么就要访问 $20000$ 个块。

    + 如果 $V(R,a)=100$ 且索引是聚簇的，查询代价估计 $=1000/100=10$ 个 I/O，$V(R, a)$ 表示 $a$ 属性在 $R$ 中出现的不同值的个数。

      > 有索引的帮助，可以快速定位到这个元组，再加上是聚簇的，所以相同值的也是相邻的。
      >
      > 因为有 $100$ 个不同的值，所以在最坏情况下平均分散到 $10$ 个块里面。

    + 如果 $V(R,a)=100$ 且索引是非聚簇的，查询代价 $=~20000/100=200$ 个 I/O。

    + 如果 $V(R,a)=20000$，即 $a$ 是关键字，主键索引，查询代价 $=~20000/20000=1$ 个 I/O，不管是否是聚簇的。

+ 基于有序索引的连接算法（Zig-Zag 连接算法）:
  + 以 $R$ 和 $S$ 做等值连接为例。
  + $R$ 和 $S$ 都有在 Y 属性上的 B+ 树索引。
  + $R$ 和 $S$ 均从左至右读取索引树的叶子结点：
    1. 读R的第一个索引项赋予a，再读S的第一个索引项赋予b；
    2. 如果 $a\not=b$，则：
       + 如果 $a<b$，则将 $R$ 的下一个索引项赋予 $a$，继续执行 $2$。
       + 如果 $a>b$，则将 $S$ 的下一个索引项赋予 $b$，继续执行 $2$。
    3. 如果 $a=b$，则将 $R$ 和 $S$ 关系中对应的元组读出并进行连接，直到 $R$ 的所有相等的 $a$ 值和 $S$ 的所有相等的 $b$ 值对应的元组都处理完毕，将 $R$ 的下一个索引项赋予 $a$，继续执行 $2$。

### 5.5.两阶段多路归并排序 TPMMS

+ 基本思路：

  + 第一趟：

    ​	划分子集，并使子集具有某种特性，如有序或相同散列值等。

  + 第二趟：

    ​	处理全局性内容的操作，形成**结果**关系。如**多子集间的归并排序**，相同散列值子集的操作等。

+ 内排序：

  ​	待排序的数据可一次性地装入内存中，即排序者可以完整地看到和操纵所有数据。内存中数据的排序算法：插入排序算法、选择排序算法、冒泡排序算法等。

+ 外排序：

  ​	待排序的数据不能一次性装入内存，即排序者不能一次完整地看到和操纵所有数据，需要将数据分批装入内存分批处理的排序问题。

+ 多路归并的过程（仅简单分析）：

  + 设内存块数为 $B_{memory}$，待排序数据块数：$B_{problem}$。

  + 第一趟划分子集并排序，这里要求每个子集的块数要小于内存块数 $B_{memory}$，I/O 次数为 $2B_{problem}$。

  + 第二趟各子集间的归并排序，这里要求子集的数目要小于内存块数 $B_{memory}$，I/O 次数为 $2B_{problem}$。

    > 这两个限制说明大数据集块数 $\le B^2_{memory}$。
    >
    > 同时内存的块中得有一块用来输出，一块用来比较（老师说可以没有），实际上限制更严格一点。

  + 算法的效率：读写磁盘块的次数，即 I/O数 $=4B_{problem}$。

### 5.6.数据库查询优化技术

+ 从三个层面进行优化：

  + 语义优化：

    + 利用模型的语义及完整性规则，优化查询。
    + 去掉无关的表
    + 去掉无关的属性
    + 改写成等价的效果更好的语句

  + 语法优化（逻辑层优化）：

    + 利用语法结构，**优化操作执行顺序**。
    + 尽可能早做选择运算
    + 尽可能早做投影运算
    + 改写成**等价**的效果更好的语句

  + 执行优化（物理层优化）：

    ​	**存取路径和执行算法的选择**与**执行次序**优化，同 [5.1.概论中的物理层](#5.1.概论)。

+ 用语法树表达关系代数表达式：

  + 长这样：

    <img src=".\Database Systems.assets\image-20211021164943547.png" alt="image-20211021164943547" style="zoom:67%;" />

  + 策略：

    + 尽可能地早做选择和投影：可使中间结果变小，节省几个数量级的执行时间。
    + 把选择与投影串接起来：一元运算序列可一起执行，只需对整个关系扫描一遍。
    + 把投影与其前或后的二元运算结合起来：在第一次用关系时去掉一些无关属性，可以避免多次扫描整个关系。
    + 把某些选择与其前的笛卡尔积合并成一个连接：当 R×S 前有选择运算且其中有条件是 R、S 属性间比较的运算时，可将其转化为连接运算可节省时间。
    + 执行连接运算前对关系做适当预处理：文件排序、建立临时索引等，可使两关系公共值高效联接。
    + 找出表达式里的公共子表达式：若公共子表达式结果不大，则预先计算，以后可读入此结果，节时多，尤当视图情况下有用。

  + 关系代数操作次序交换的等价性：

    + 连接与连接，积与积的交换律
    + 连接与连接、积和积的结合律

+ 代价估算：

  + 估算一个 $\pi_{\mathrm{L}}(\mathrm{R})$ 的大小
    >简单: $\mathrm{T}\left(\pi_{\mathrm{L}}(\mathrm{R})\right)=\mathrm{T}(\mathrm{R})$
    >投影运算只是对列有所取舍, 并末对行有所变化，如并末消除重复 >投影运算并末减少行数, 但可能有效地减少了存储结果关系的块数

  + 估算选择运算 $S=\sigma_{A=c}(R)$ 的大小：
    $\mathrm{T}(\mathrm{S})$ 介于 $[0,\mathrm{T}(\mathrm{R})-\mathrm{V}(\mathrm{R}, \mathrm{A})+1]$ 之间

    最多：A属性不同值的元组都只存在一个, 剩余的 估计: $\mathrm{T}(\mathrm{S})=\mathrm{T}(\mathrm{R}) / \mathrm{V}(\mathrm{R}, \mathrm{A})$
    －-A属性不同值的元组数假设是平均分布的
    当不知道 $V(R, A)$ 时，估计: $T(S)=T(R) / 10$.

  + 估算选择运算 $\mathrm{S}=\sigma_{\mathrm{A}<\mathrm{c}}({R})$ 的大小：
    $\mathrm{T}(\mathrm{S})$ 介于 0 to $\mathrm{T}(\mathrm{R})$ 之间
    一-最多：所有元组都满足条件
    估计: $\mathrm{T}(\mathrm{S})=\mathrm{T}(\mathrm{R}) / 2$
    －直觉，应有一半的元组，
    实际应用的估计: $\mathrm{T}(\mathrm{S})=\mathrm{T}(\mathrm{R}) / 3$

  + $>$ 估计: $\mathrm{T}(\mathbf{S})=\mathrm{T}(\mathrm{R}) /\left(\mathbf{V}(\mathrm{R}, \mathbf{A})^{*} 3\right)$
    $\left.\cdots \sigma_{A=10} \operatorname{AND} B<20(R)=\sigma_{B<20}\left(\sigma_{A=10}(R)\right)\right)$
    - - $A=10$, 得出 $T(S)=T(R) / V(R, A) ;$
    $--\mathrm{B}<20$, 得出 $\mathrm{T}(\mathrm{S})=\mathrm{T}(\mathrm{S}) / 3$

    >估计: $\mathrm{T}(\mathrm{S})=\mathrm{n}\left(1-\left(1-\mathrm{m}_{1} / \mathrm{n}\right)\left(1-\mathrm{m}_{2} / \mathrm{n}\right)\right)$
    >‥-R有 $n$ 个元组，其中有 $m_{1}$ 个满足C1, 有 $m_{2}$ 个满足C2
    $\left(1-\mathrm{m}_{1} / \mathrm{n}\right)$ 是不满足C1的那些元组, $\left(1-\mathrm{m}_{2} / \mathrm{n}\right)$ 是不满足C2的那些元组
    ـ--两数之积是不在S中的那部分R的元组， 1 减去这个积就是属于S的那部分元组 出现的概率。

## 6.数据库事务处理技术

### 6.1.

+ 事务的概念：

  ​	事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制， 以便数据库管理系统能够提供一致性状态转换的保证。

+ 事务的宏观性（应用程序员看到的事务）：

  ​	一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务。

  > 事务一般是由应用程序员提出，因此有开始和结束，结束前需要提交或撤消（通过 commit 或 rollback 确认的）。

+ 事务的微观性（DBMS看到的事务）：

  ​	对数据库的一系列基本操作（读、写）的一个整体性执行。

+ 事务的并发执行：

  ​	多个事务从宏观上看是并行执行的，但其微观上的基本操作（读、写）则可以是交叉执行的。

+ 并发控制就是通过事务微观交错执行次序的正确安排，保证事务宏观的独立性、完整性和正确性。

+ 事务的特性（ACID 特性）：

  + 原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。
  + 一致性：隔离执行事务时 （换言之，在没有其他事务并发执行的情况下）保持数据库的一 致性。
  + 隔离性：尽管多个事务可能并发执行, 但系统保证, 对于任何一对事务 $T_{\mathrm{i}}$ 和 $T_{\mathrm{j}}$，在 $T_{i}$ 看来，$T_{j}$ 或者在 $T_{\mathrm{i}}$ 开始之前已经完成执行，或者在 $T_{\mathrm{i}}$ 完成之后开始执行。因此，每个事务都感觉不到系统中有其他事务在并发地执行。
  + 持久性：一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障。

  > 具有 ACID 特性的若干数据库基本操作的组合体被称为事务。

### 6.2.事务调度

+ 事务调度概念：

  ​	一组事务的基本步骤（读、写、其他控制操作如加锁、解锁等）的一种执行顺序称为对这组事务的一个调度。

+ 并发（或并行）调度：

  ​	多个事务从宏观上看是并行执行的，但其微观上的基本操作（读、写）则是交叉执行的。

+ 并发调度的正确性：

  ​	当且仅当在这个并发调度下所得到的新数据库结果分别串行地运行这些事务所得的新数据库完全一致，调度才是正确的。

+ 可串行性：

  ​	如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个串行调度相同，则我们说这个调度是可串行化的或具有可串行性。

  > 可串行化调度一定是正确的并行调度，但正确的并行调度，却未必都是可串行化的调度。
  >
  > 因为并行调度的正确性是指**内容上**结果正确性（结果对就对了），而可串行性是指**形式上**结果正确性，便于操作。

+ 一种简单的事务调度的标记模型：

  + $r_T(A)$： 事务 T 读 A。
  + $w_T(A)$：事务 T 写 A。

+ 冲突：

  + 调度中一对连续的动作：如果它们的顺序交换，那么涉及的事务中至
    少有一个事务的行为会改变。
  + 有冲突的两个操作是不能交换次序的，没有冲突的两个事务是可交换的
  + 几种冲突的情况：

+ 冲突可串行性： 

  ​	一个调度，如果通过交换相邻两个无冲突的操作能够转换到某一个串行的调度，则称此调度为**冲突可串行化**的调度。



### 6.3.锁

+ 锁的类型：

  + 排他锁 X：

    ​	只有一个事务能读、写，其他任何事务都不能读、写。

  + 共享锁 S：

    ​	所有事务都可以读，但任何事务都不能写。

  + 更新锁 U：

    ​	初始读，以后可升级为写。

  + 增量锁 I：

    ​	增量更新（例如 $A=A+x$）区分增量更新和其他类型的更新。

+ 
